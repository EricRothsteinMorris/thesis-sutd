%!TEX root = ../main.tex
% Chapter Template

\newcommand{\branch}[3]{\ensuremath{{#2}\ {+_{#1}}\ {#3}}}
\newcommand{\iterate}[2]{\ensuremath{{#1}^{\left(#2\right)}}}
\newcommand{\bexp}[0]{\ensuremath{\text{BExp}}}
\newcommand{\gexp}[0]{\ensuremath{\text{Exp}}}
\newcommand{\usg}[0]{\ensuremath{\text{u}}}
\newcommand{\eval}[0]{\ensuremath{\mathtt{eval}}}
\newcommand{\sat}[0]{\ensuremath{\mathtt{sat}}}
\newcommand{\sg}[0]{\ensuremath{\text{s}}}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}}
\newcommand{\lbl}[0]{\ensuremath{\text{lbl}}}
\newcommand{\Real}[0]{\ensuremath{\mathbb{R}}}
\newcommand{\letter}[0]{\ensuremath{\left(\text{A-Z\ |\ a-z}\right)}}
\newcommand{\Atom}[0]{\ensuremath{\text{At}}}
\newcommand{\GuardedString}[0]{\ensuremath{\text{GS}}}
\newcommand{\RC}[0]{\ensuremath{\text{RC}}}
\newcommand{\Low}[0]{\ensuremath{\text{Low}}}
\newcommand{\Variable}[0]{\ensuremath{\mathcal{V}}}
\newcommand{\Integer}[0]{\ensuremath{\mathbb{Z}}}
\newcommand{\alphanumeric}[0]{\ensuremath{\left(\text{A-Z\ |\ a-z\ |\ 0-9}\right)}}
\newcommand{\alphanumericP}[0]{\ensuremath{\left(\text{A-Z\ |\ a-z\ |\ 0-9\ |\ .\ |\ \_\ |\ \$}\right)}}
\newcommand{\semantics}[1]{\ensuremath{\llbracket #1\rrbracket}}
\newcommand{\valuation}[0]{\ensuremath{\Gamma}}
\newcolumntype{L}{>{$}l<{$}} % math-mode version of "l" column type
\newcolumntype{R}{>{$}r<{$}} % math-mode version of "r" column type
\newcolumntype{C}{>{$}c<{$}} % math-mode version of "c" column type

\chapter{Side-Channel Repair} % Main chapter title

\label{ChapterGKAT} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{General Idea}
In the following, whenever we write \emph{program}, we mean \emph{non-concurrent program}
The premises of our work are the following:
\begin{itemize}
\item Every program can be linearised using a set of \emph{predication axioms}.
\end{itemize}

\section{Related work and how do we distinguish from them}
\begin{itemize}
\item Ashay Rane: we do not use \emph{cmove} as a primitive instruction, since it \todo{prove this?}may be vulnerable to spectre attacks
\end{itemize}

\section{CTP (Cryptocoding) Axioms, and our solution}
Taken from \cite{cryptocoding}.
\begin{itemize}
\item Compare secrets in constant time.
\begin{itemize}
\item We implement a constant-time comparison function for each type at the LLVM IR. Do note that there are several comparison operations: leq, geq, neq, etc. Ideally, we have a way to implement them at the IR level, but this might not be possible; in other words, there may be the need to leave these as primitive operations that are translated differently for the different architectures. This latter approach has its advantages though: there is room for optimization and we can ensure that it, in fact, gets translated to a sequence of constant time instructions; however, it requires more muscle, i.e., we need to be super careful on how we translate them so that they are, in fact, constant time. 
\end{itemize}
\item Avoid branchings controlled by secret data
\begin{itemize}
\item The suggested solution: 
\begin{quote}
Timing leaks may be mitigated by introducing dummy operations in branches of the program in order to ensure a constant execution time. It is however more reliable to avoid branchings altogether, for example by implementing the conditional operation as a straight-line program. To select between two inputs a and b depending on a selection bit (a la CTSelect). 
\end{quote}
\item We implement predication axioms that allow us to transform control structures into arithmetic expressions using Shannon expansions.
\end{itemize}
\item Avoid table look-ups indexed by secret data
\begin{itemize}
\item The suggested solution: 
\begin{quote}
Replace table look-up with sequences of constant-time logical operations, for example by bitslicing look-ups (as used in NaCl's implementation of AES-CTR, or in Serpent. For AES, constant-time non-bitsliced implementations are also possible, but are much slower. (check blog for resources on how to do this).
\end{quote}
\item The two available options is to somehow implement a rudimentary version of ORAM or make lookups on a set generated by the secret (which should probably be similar to what bit slicing is).
\end{itemize}
\item Avoid secret-dependent loop bounds
\begin{itemize}
\item The suggested solution: 
\begin{quote}
Make sure that all loops are bounded by a constant (or at least a non-secret variable). In particular, make sure, as far as possible, that loop bounds and their potential underflow or overflow are independent of user-controlled input (you may have heard of the Heartbleed bug).
\end{quote}
\item Our solution: each secret has an associated iteration bound (i.e., loops that depend on that secret will be unfolded that number amount of times).
\end{itemize}
\item Prevent compiler interference with security-critical operations (i.e., compilers can mess up your patches)
\begin{itemize}

\item The suggested solution: 
\begin{quote}
Look at the assembly code produced and check that all instructions are there. (This will not be possible for typical application sizes, but should be considered for security-sensitive code.)

Know what optimizations your compiler can do, and carefully consider the effect of each one on security programming patterns. In particular, be careful of optimizations that can remove code or branches, and code that prevents errors which "should be impossible" if the rest of the program is correct.

When possible, consider disabling compiler optimizations that can eliminate or weaken security checks.

Note that such workarounds may not be sufficient and can still be optimized out.
\end{quote}
\item Our solution: we suggest that CTFixes happen as latter as possible in the compilation chain. We can only offer guarantees at the LLVM IR level, the rest is target specific (this is acceptable, since the repair paper works at the same level).
\end{itemize}

\item Prevent confusion between secure and insecure APIs
\item Avoid mixing security and abstraction levels of cryptographic primitives in the same API layer
\item Use unsigned bytes to represent binary data
\begin{quote}
Some languages in the C family have separate signed and unsigned integer types. For C in particular, the signedness of the type char is implementation-defined. This can lead to problematic code.
\end{quote}
\begin{itemize}
\item Their suggestion:
\begin{quote}
In languages with signed and unsigned byte types, implementations should always use the unsigned byte type to represent bytestrings in their APIs.
\end{quote}
\item our solution: LLVM IR does uses both signed and unsigned. We need an axioms to only yield unsigned byte types.
\end{itemize}
\item Clean memory of secret data
\begin{itemize}
\item Our suggestion: although this might take a lot of time, it is a good idea to reset all input secrets and their intermediate operations. 
\end{itemize}
\item Use strong randomness
\begin{itemize}
\item Our suggestion: we cannot really enforce this. We assume it. (TBH I dunno how does randomness work on the LLVM IR).
\end{itemize}
\item Always typecast shifted values\todo{read blog}.
\end{itemize}

Do note also the following:
\begin{itemize}
\item Casting operations at higher level may be dangerous: they might introduce branching at the lower level for some architectures (there is an example where a \_Bool is casted into an uint\_32 in the blog.
\end{itemize}
\section{Formalisation}
We first present Guarded Kleene Algebra with Tests (GKAT) \cite{GKAT}.
\newline
\begin{minipage}{0.5\textwidth}
\begin{align*}
\begin{tabular}{RCLL}
\multicolumn{4}{L}{b,c,d, \in \bexp::=} \\
  &    |   &  0   		&  \textbf{False}   \\
  &    |   &   1   		&   \textbf{True}   \\
  &    |   &    t\in T  		&   t  \\
  &    |   &    b \cdot c  	&  b \ \textbf{and}\ c   \\
  &    |   &    b+c  		&   b \ \textbf{or}\ c   \\
  &    |   &    \bar{b}  	& \textbf{not}\ b
\end{tabular}
\end{align*}
\end{minipage}%
\begin{minipage}{.5\textwidth}
   \begin{align*}
\begin{tabular}{RCLL}
\multicolumn{4}{L}{e,f,g, \in \gexp::=} \\
  &    |   &  p \in \Sigma  	&  \textbf{False}   \\
  &    |   &   b \in \bexp   	&   \textbf{True}   \\
  &    |   &    e \cdot f  	&  b \ \textbf{and}\ c   \\
  &    |   &   \branch{b}{f}{g} 		&   b \ \textbf{or}\ c   \\
  &    |   &    \iterate{e}{b} 	& \textbf{not}\ b
\end{tabular}
\end{align*}
\end{minipage}

In the context of constant time programming (CTP), actions $a\in \Sigma$ correspond to instructions in LLVM IR. However, before we explore the concrete meaning of instructions, we use the GKAT framework to define notions for CTP.
\subsection{Language-Based Semantics CTP}
Given a GKAT expression $e$, its language-based semantics corresponds to a language of \emph{guarded strings}. Before we introduce the notion of guarded strings, we must introduce the notion of (logical) \emph{atoms}. Informally, each atom is a valuation of all tests in the set of tests $T$; e.g., if $T=\{t_1,t_2\}$, the expressions  $\overline{t_1}\land \overline{t_2}$, $\overline{t_1}\land {t_2}$, $t_1\land \overline{t_2}$, and $t_1\land {t_2}$ are the atoms. Formally, atoms correspond to non-zero minimal elements in the free boolean algebra in $T$ \cite{KAT}. We denote atoms by $\alpha, \beta,$ and $\gamma$, and the set of atoms by $\Atom$.

\begin{definition}[Guarded String]
Given a set of actions $\Sigma$ and a set of tests $T$, a \emph{guarded string} $g$ is an element of the set $\GuardedString := \Atom \cdot \left(\Sigma\cdot \Atom\right)^{*}$.
\end{definition}

\begin{definition}[Resource Consumption]
A \emph{resource metric} is a map $m\colon \GuardedString \rightarrow \Sigma \rightarrow \Real^{+}$; given a guarded string $g$, $m(g)(a)$ is the resource consumption for the action $a$ after executing all the actions in $g$. The \emph{resource consumption} of $g$, denoted $\RC(g)$, is the accumulated resource consumption of its actions; formally,
\begin{align}
\RC(g)&\triangleq 
\begin{cases}
0, &\quad \text{if $g=\alpha$;}\\
\RC(h) + m(h)(a),&\quad \text{if $g=h \cdot a\cdot \alpha $;}\\
\end{cases}
\end{align}

Henceforth, we will assume that resource metrics are history-independent, i.e., resource consumption is independent of previous actions or initial conditions, meaning that resource metrics are instead maps of type $\Sigma \rightarrow \Real^{+}$.  
\todo[inline]{Are there relevant cases where this is not true?}

\end{definition}

\begin{definition}[Strong Constant Time]
Given a language of guarded strings $L\subseteq \GuardedString$, we say that $L$ has \emph{strong constant time} guarantees if and only if, for all $g_1, g_2 \in L$, $\RC(g_1)=\RC(g_2)$. 
\end{definition}
To obtain the notion of constant time that is used for security analysis, we need to match traces that are only equal on their public variables. Atoms themselves may match even when public values are different (e.g. if $p$ is public, the test $p\leq 128$ is satisfied by any public value below 128); thus, we need to make the state of public variables explicit. For such purposes, let $\Variable$ be the set of variables, and let $\semantics{\Variable}$ be the set of valuation functions which map variables to values; we override the definition of guarded strings so that the set of guarded strings is now generated by the grammar
\begin{align}
\GuardedString := \left(\semantics{\Variable}\times\Atom\right) \cdot \left(\Sigma\cdot \left(\semantics{\Variable}\times\Atom\right)\right)^{*}.
\end{align}
Thus, guarded strings now satisfy either the pattern $(\valuation,\alpha)$ or the pattern $(\valuation,\alpha)\cdot a\cdot h$, where $\valuation$ is a valuation of the variables, $\alpha$ is an atom and $h$ is a guarded string.

\begin{remark}
{If the domains of variables are finite, this formulation reduces to the original formulation as follows: for each variable $p$ and each of its possible values $v$, we include the proposition $p=v$ in the set of tests.}
\end{remark}
\begin{definition}[Public Equality]
Whenever two valuations $\valuation_1$ and $\valuation_2$ are equal on their public variables, we denote it by $\valuation_1=_p\valuation_2$. Two guarded strings $g_1$ and $g_2$ are equal on their public variables, denoted $g_1=_p g_2$, if and only if their \emph{initial} valuations are equal on public variables. 
\end{definition}
\begin{definition}[Secure Constant Time]
Given a language of guarded strings $L\subseteq \GuardedString$, we say that $L$ has \emph{secure constant time} guarantees if and only if, for all $g_1, g_2 \in L:$
\begin{align}
g_1=_p g_2\Rightarrow\RC(g_1)=\RC(g_2).
\end{align}
\end{definition}

\section{The IMP Language with Division}
We modify the simple imperative programming language with variable assignments and boolean expressions from \cite{GKAT} --IMP-- to include division; the language is defined as follows:
\begin{align*}
{\small
\begin{tabular}{R RL}
\text{arithmetic expressions} & a\in \mathscr{A}\!\!\!\!\!\! &::= x\in \Variable\ |\ n \in \Real_\perp\ |\ a_1+a_2\ |\ a_1-a_2\ |\ a_1\times a_2\ |\ a_1 \div a_2\\
\text{boolean expressions} & b\in \mathscr{B}\!\!\!\!\!\! &::= \textbf{false}\ |\ \textbf{true}\ |\ a_1<a_2\ |\ a_1-a_2\ |\ \textbf{not } b\ |\ b_1 \textbf{ and } b_2\ |\ b_1 \textbf{ or } b_2\\
\text{commands} & c\in \mathscr{C}\!\!\!\!\!\! &::= \textbf{skip}\ |\ x:=a\ |\ c_1;c_2\ |\ \textbf{if }b\text{ then }c_1\text{ else }c_2\ |\ \textbf{while } b\textbf{ do }c
\end{tabular}
}
\end{align*}
where $\Real_\perp=\Real \uplus \{\perp\}$, and $\perp$ is a symbol to denote \emph{not-a-number} (NaN).

As stated in \cite{GKAT}, this language can be modelled in GKAT using actions for assignments and primitive tests for comparisons as follows:
\begin{align}
\Sigma=\set{x:=a\ |\ x\in \Variable, a\in \mathscr{A}}, \quad T=\set{a_1 < a_2\ |\ a_1,a_2\in \mathscr{A}}.
\end{align}
Following \cite{GKAT}, we interpret GKAT expressions over the space of variable assignments $\semantics{\Variable}\triangleq\Variable \rightarrow\Real_\perp$:
\begin{align*}
\eval(x:=a)&\triangleq \set{(\sigma, \sigma[x:=n])\ |\  \sigma \in \semantics{\Variable}, n=\mathscr{A}\semantics{a}_\sigma},\\
\sigma[x:=n]&\triangleq \uplambda y \ldotp 
	\begin{cases}
		n, \quad &\text{if $y=x$};\\
		\sigma(y), \quad&\text{otherwise},
	\end{cases}\\
\sat(a_1<a_2)&\triangleq \set{\sigma \in \semantics{\Variable}\ |\ \mathscr{A}\semantics{a_1}_{\sigma} < \mathscr{A}\semantics{a_2}_{\sigma}},
\end{align*}
%where $\mathscr{A}\semantics{a}_\sigma\colon \semantics{\Variable}\rightarrow \Real_\perp$ denotes arithmetic evaluation of the expression $a$ in the context of $\sigma$.
where $\mathscr{A}\semantics{a}_\sigma$ denotes the arithmetic evaluation of $a$ in the context of $\sigma$. Finally, sequential composition, conditionals and while loops are modelled by their GKAT counterparts, and $\mathbf{skip}$ is modelled by 1.

\subsection{Transformations for Secure Constant Time in IMP}
\subsection{Types}
For our first LLVM IR sublanguage, we support the following types:
\begin{itemize}
\item Void type, which cannot be assigned to variables.
\item Integer types of the form $i_N$ where $N\in [1..2^{23}-1]$.
\end{itemize}
An element of type $i_N$ is a vector of $N$ bits; consequently, the type $i_N$ is populated by maps of the form $N\rightarrow 2$\todo{Set Notation}. There are two standard interpretations for $x\colon i_N$, an \emph{unsigned} interpretation $\usg\colon i_N\rightarrow \mathbb{N}$, where 
\begin{align}
\usg(x)= \sum_{n=0}^{N-1} x(n)\times2^{x(n)},
\end{align}
and a \emph{signed} interpretation $\sg\colon i_N\rightarrow \mathbb{Z}$, where
\begin{align}
\sg(x)= 
\begin{cases}
\ \ \ \ \sum_{n=1}^{N-1} x(n)\times2^{x(n)},\quad &\text{if $x(0)=0$};\\
-\sum_{n=1}^{N-1} x(n)\times2^{x(n)},\quad &\text{if $x(0)=1$}.
\end{cases}
\end{align}
In other words, the first bit $x(0)$ determines whether $x$ represents a positive or a negative number under the signed representation.

For the set of instructions we need to introduce the notion of variables and assignments. The set of \emph{variables} $v$ is generated by the regular expression
\begin{align}
v::= (@\ |\ \%)\cdot\letter\cdot\alphanumericP^{*}.
\end{align}
A \emph{variable assignment} is an instruction of the form $v:=e$, where $e$ is a \emph{non-void function} or an \emph{arithmetic expression}. Arithmetic expressions are 
\begin{itemize}
\item Language  
\item Arithmetic operations that use division.
\end{itemize}
\subsection{Instructions} 
\todo[inline]{Overflows}

\subsection{Central idea}
The main theoretical idea of our work is\todo{what is it?}
   %-----------------------------------
%	SUBSECTION 1
%-----------------------------------
\subsection{Subsection 1}

Nunc posuere quam at lectus tristique eu ultrices augue venenatis. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Aliquam erat volutpat. Vivamus sodales tortor eget quam adipiscing in vulputate ante ullamcorper. Sed eros ante, lacinia et sollicitudin et, aliquam sit amet augue. In hac habitasse platea dictumst.

%-----------------------------------
%	SUBSECTION 2
%-----------------------------------

\subsection{Subsection 2}
Morbi rutrum odio eget arcu adipiscing sodales. Aenean et purus a est pulvinar pellentesque. Cras in elit neque, quis varius elit. Phasellus fringilla, nibh eu tempus venenatis, dolor elit posuere quam, quis adipiscing urna leo nec orci. Sed nec nulla auctor odio aliquet consequat. Ut nec nulla in ante ullamcorper aliquam at sed dolor. Phasellus fermentum magna in augue gravida cursus. Cras sed pretium lorem. Pellentesque eget ornare odio. Proin accumsan, massa viverra cursus pharetra, ipsum nisi lobortis velit, a malesuada dolor lorem eu neque.

%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Main Section 2}

Sed ullamcorper quam eu nisl interdum at interdum enim egestas. Aliquam placerat justo sed lectus lobortis ut porta nisl porttitor. Vestibulum mi dolor, lacinia molestie gravida at, tempus vitae ligula. Donec eget quam sapien, in viverra eros. Donec pellentesque justo a massa fringilla non vestibulum metus vestibulum. Vestibulum in orci quis felis tempor lacinia. Vivamus ornare ultrices facilisis. Ut hendrerit volutpat vulputate. Morbi condimentum venenatis augue, id porta ipsum vulputate in. Curabitur luctus tempus justo. Vestibulum risus lectus, adipiscing nec condimentum quis, condimentum nec nisl. Aliquam dictum sagittis velit sed iaculis. Morbi tristique augue sit amet nulla pulvinar id facilisis ligula mollis. Nam elit libero, tincidunt ut aliquam at, molestie in quam. Aenean rhoncus vehicula hendrerit.