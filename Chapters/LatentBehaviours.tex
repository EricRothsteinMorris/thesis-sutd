%!TEX root = ../main.tex
% Chapter Template


\chapter{Foundations of Latent Behaviour Analysis} % Main chapter title
\label{ch:LatentBehaviours} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}
% \todo[inline]{Find a suitable quote?}
% \begin{quote} 
%     "If you only do what you can do, you will never be more than what you are now." -- Master Shifu.
% % "As you adequately put, the problem is choice. But we already know what you are going to do, don't we?" -- The Architect.
% \end{quote} 

\section{Introduction}
\label{sec:Latent:Introduction}
A \emph{latent behaviour} is an unintended functionality of a system, which the system typically does not display. Still, given extraordinary circumstances, the system displays such functionality. To create a latent behaviour, we transform the state space of the system. Since the state space is usually not transformed, we model "extraordinary circumstances" using these transformations. This concept is probably well illustrated by \emph{return-oriented programming} (ROP) as described in~\cite{ROP}, where the attacker, to alter the behaviour of the running program, does not modify the code of the running program and instead transforms the state of the call stack.

In ROP, the adversary manipulates the call stack to string code gadgets together and arbitrarily execute code. However, if the program is small and does not have enough gadgets, then the attacker's computational power is restricted since it becomes impossible to create certain behaviours. This restriction is similar to the limitations we face when working with non-Turing complete languages (e.g., we cannot use regular expressions to specify arbitrary Turing machines). However, given enough gadgets, we can create any behaviour we want if we appropriately compose the gadgets.

In this section, we explain the commutative diagram presented in Figure~\ref{fig:TheArrow}. This diagram, which we refer to as \emph{the Arrow}, illustrates how spatial and dynamics transformations affect the behaviour of an $F$-coalgebra $(X,c)$ by changing the semantic map from $!_c$ to $!_{b\circ c\circ m}$. 
The intuitive meaning of Arrow is the following: normally, an $F$-coalgebra $(X,c)$ gives semantics to the elements in $X$ via the semantic map $!_c$. When affected by a spatial transformation $m\colon X\rightarrow X$ and a dynamics transformation $b\colon F(X)\rightarrow F(X)$, the $F$-coalgebra $(X,c)$ creates an $F$-coalgebra $(X,b\circ c\circ m)$. 
The behaviour of elements in $(X,b\circ c\circ m)$ may bear no resemblance to the original behaviour. At best, we can conclude that if $m$ and $b$ preserve bisimilarity, then there exists a transformation $\omega\colon \sigma F \rightarrow \sigma F$ in the carrier of the final $F$-coalgebra $(\sigma F, 1)$ where $\omega$ maps the original behaviours of the system into the new behaviours created by $m$ and $b$. 

\begin{figure}[ht]
        \centering
        \begin{tikzcd}[column sep=1.75cm, row sep=1cm]
            &\sigma F
                \arrow[dr,swap,"\omega"']
            &
            \\ 
            X  
                \arrow[dd,"c"] 
            & X
                \arrow[l, swap, "m"]
                \arrow[u, "!_{c}"]
                \arrow[r,dotted, swap, "!_{b\circ c\circ m}"]
            &\sigma F 
                %\arrow[dd, "\simeq","\omega"']
                \arrow[dd, "1_F"]
                \arrow[dr, "\textbf{id}"]
            \\
            &&&\sigma(F)
            \\
            F(X)     
                \arrow[r, swap, "b"]
            &F(X)
                \arrow[d, swap, "F(!_{c})"]
                \arrow[r, dotted, "F(!_{b\circ c\circ m})"] 
            &
            F(\sigma F)
                %\arrow[ur, swap, "\omega^{-1}"]
                \arrow[ur, swap, "1_F^{-1}"]
            \\
            &F(\sigma F)
                \arrow[ru, swap, "F(\omega)"]
            &
        \end{tikzcd}
        \caption{``The Arrow of Latent Behaviour Analysis.'' This commutative diagram summarises the effect of spatial and dynamics transformations over the $F$-coalgebra $(X,c)$, respectively modelled by $m$ and $b$: the semantic map changes from $!_c$ to $!_{b\circ c\circ m}$. Through this work, we assume $b=\id$.}
        \label{fig:TheArrow} 
    \end{figure}

%\section{Motivational Example: Modelling Faults with Spatial Transformations}
\section{Motivational Example}
\label{sec:Latent:Motivation}
% \todo[inline]{Small intro to transformed systems. You should have mentioned already somewhere in the intro that there are two ways to mutate the behaviour of a system in the coalgebra world: by transforming the carrier or by transforming the co-carrier. We only study transformations of the carrier.}
% \todo[inline]{I feel like we are missing some stuff? How are we going to structure the introduction?}
Consider the automaton in Figure~\ref{fig:ExampleLatent}, which recognises the language of sequences in $2^*$ that end in two consecutive 1; i.e., the language $(0|1)^*11$. 
This automaton is defined by the tuple $(\vec{X},\vec{x}_0,\delta,F)$; the carrier is $\vec{X}\triangleq2\times2$, the initial state selector is $\vec{x}_0\colon1\rightarrow \vec{X}$ with $\vec{x}_0(0)\triangleq(0,0)$, the transition function is $\delta\colon \vec{X}\rightarrow 2\rightarrow\vec{X}$, defined for $\vec{x}\in \vec{X}$ and $i \in 2$ by $\delta(\vec{x})(i)\triangleq(i,\vec{x}[0]),$ and the characteristic predicate of the set of accepting states is $F\colon\vec{X}\rightarrow 2$, where $F(x,y)\triangleq x \land y$
%$F(1,1)\triangleq1$ and $F(x,y)\triangleq0$ otherwise
(i.e. $(1,1)$ is the only accepting state). This automaton is not minimal since the states $(0,0)$ and $(0,1)$ are different, yet they are bisimilar. 

\begin{figure}[t]
    \centering
    \begin{tikzpicture}
        \node[state,initial] (00) {$(0,0)$};
        \node[state, below right of=00] (01) {$(0,1)$};
        \node[state, above right  of=00] (10) {$(1,0)$};
        \node[state, accepting, below right of=10] (11) {$(1,1)$};
        \draw (00) edge[bend left, above] node{1} (10)
        (00) edge[loop above] node{0} (00)
        (01) edge[bend left, left] node{1} (10)
        (01) edge[bend left, above] node{0} (00)
        (10) edge[bend left, above] node{1} (11)
        (10) edge[bend left, right] node{0} (01)
        (11) edge[loop above] node{1} (11)
        (11) edge[bend left, above] node{0} (01)
        ;\end{tikzpicture}
    \caption{An automaton which recognises the language $(0|1)^*11$.}
    \label{fig:ExampleLatent}
\end{figure}

Now, consider a transformation %assume that the programmer is malicious, and they purposely 
% consider a transformation $m\colon \vec{X}\rightarrow\vec{X}$ which maps $(a,b)\in \vec{X}$ to $(\lnot a, \lnot b)$. 
$m\colon \vec{X}\rightarrow\vec{X}$, defined by $m(\vec{x})\triangleq(\lnot \vec{x}[0],\lnot \vec{x}[1])$ for $\vec{x}\in \vec{X}$; i.e., $m$ maps $(a,b)$ to $(\lnot a, \lnot b)$. This transformation implements some fault which could be introduced by a malicious programmer or by an attacker which corrupts the state of the system. Due to this transformation, %e compute state transformations before computing the behaviour; thus, 
if the current state is $\vec{x}=(a,b)$, when we intend to check whether $\vec{x}$ is accepting, we check whether $(\lnot a, \lnot b)$ is accepting instead, and when we intend to compute $\delta(\vec{x})(i)$, we instead compute $\delta(\lnot a, \lnot b)(i)$. 
\begin{figure}[t]
    \centering
\begin{tikzpicture}
    \node[state, initial, accepting] (00) {$(0,0)$};
    \node[state, below right of=00] (01) {$(0,1)$};
    \node[state, above right  of=00] (10) {$(1,0)$};
    \node[state, below right of=10] (11) {$(1,1)$};
    \draw (00) edge[bend right, above] node{1} (11)
    (00) edge[bend right, above] node{0} (01)
    (01) edge[bend right, above] node{1} (11)
    (01) edge[loop below] node{0} (01)
    (10) edge[loop above] node{1} (10)
    (10) edge[bend right, above] node{0} (00)
    (11) edge[bend right, above] node{1} (10)
    (11) edge[bend right, above] node{0} (00)
    ;\end{tikzpicture}
\caption{Automaton that implements the transformed automaton, which now recognises $\varepsilon|(0|1)^*10$.}
\label{fig:Transformed}
\end{figure}

Figure~\ref{fig:Transformed} shows an implementation of the transformed automaton. This automaton recognises the language of sequences that are either empty or end in 10; i.e., $\varepsilon|(0|1)^*10$. 
Before we explain why the automaton in Figure~\ref{fig:Transformed} is the system that is created by the transformation $m$, we can first test if the transformed system recognises sequences $\varepsilon|(0|1)^*10$ due to the transformation $m$. %$(0|1)(0|1)^*$. 
To do so, let us consider pairs of states $[\vec{x},\vec{y}]$ where $\vec{x}=(x_1,x_2)$ and $\vec{y}=(y_1,y_2)$ such that the pair $\vec{x}$ follows the original behaviour while $\vec{y}$ follows the new behaviour. 
Let $[(0,0),(0,0)]$ be the initial state, and let $\delta_i\colon \vec{X}\rightarrow \vec{X}$ be the functions defined by $\delta_i(\vec{x})=\delta(\vec{x})(i)$ for $i \in 2$ (i.e., $\delta_0$ is a partial application of $\delta$ given $0$ and $\delta_1$ is a partial application of $\delta$ given 1); %, since $(1,1)$ replaces $(0,0)$ due to the fault. 
the trace of the sequence $00$ is 
\begin{align*}
   [(0,0),(0,0)]&\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{\delta_0\times\delta_0}[(0,0),(0,1)]\\
   &\xrightarrow{\id\times m}[(0,0),(1,0)]\xrightarrow{\delta_0\times\delta_0}[(0,0),(0,1)]\\
   &\xrightarrow{\id\times m}[(0,0),(1,0)]\xrightarrow{F\times F}[0,0],
\end{align*}
so $00$ is rejected by both automata. 
%Note that $\delta_0(1,1)=(0,1)$, but since $(1,0)$ replaces all read uses of $(0,1)$, we apply the fault directly. 
Now, if we receive the sequence $10$, the resulting state trace is 
\begin{align*}
    [(0,0),(0,0)]&\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{\delta_1\times\delta_1}[(1,0),(1,1)]\\
   &\xrightarrow{\id\times m}[(1,0),(0,0)]\xrightarrow{\delta_0\times\delta_0}[(0,1),(0,0)]\\
   &\xrightarrow{\id\times m}[(1,0),(1,1)]\xrightarrow{F\times F}[0,1];
\end{align*}
the transformed automaton accepts $10$, but the original automaton does not. 
The trace of the sequence $11$ is 
\begin{align*}
    [(0,0),(0,0)]&\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{\delta_1\times\delta_1}[(1,0),(1,1)]\\
   &\xrightarrow{\id\times m}[(1,0),(0,0)]\xrightarrow{\delta_1\times\delta_1}[(1,1),(1,0)]\\
   &\xrightarrow{\id\times m}[(1,1),(0,1)]\xrightarrow{F\times F}[1,0],
\end{align*}
so $11$ is accepted by the original automaton, but rejected by the transformed automaton. 
For the sequence $110$, the resulting state trace is 
\begin{align*}
    [(0,0),(0,0)]&\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{\delta_1\times\delta_1}[(1,0),(1,1)]\\
   &\xrightarrow{\id\times m}[(1,0),(0,0)]\xrightarrow{\delta_1\times\delta_1}[(1,1),(1,0)]\\
   &\xrightarrow{\id\times m}[(1,0),(0,1)]\xrightarrow{\delta_0\times\delta_0}[(0,1),(0,0)]\\
   &\xrightarrow{\id\times m}[(0,1),(1,1)]\xrightarrow{F\times F}[0,1];
\end{align*}
the transformed automaton accepts $110$, but the original automaton does not. Finally, the original automaton rejects the empty sequence $\varepsilon$, but the transformed automaton accepts it, since 
\begin{align*}
    [(0,0),(0,0)]\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{F\times F}[0,1].
\end{align*} 

% The map $m$ pairs each state with its corresponding transformed representation. %If there were no faults, the map $m$ would be the identity map. 
% The fault forces the state $(0,0)$ to behave like its image under $m$, i.e., the behaviour of $(0,0)$ in the transformed system should behave like $(1,1)$. Similarly, the state $(1,1)$ should behave $(0,0)$. 
%(We can alternatively see the function $m$ as a bad abstraction from the implementation.)

%There are now two final states: $(1,1)$ and $(0,1)$ since both states are preimages of $(1,1)$ under $m$.
We obtain the automaton in Figure~\ref{fig:Transformed} by ``copying'' the original behaviour from images of $m$ to their preimages. Figure~\ref{fig:ExampleWithFaults} shows this procedure for $(0,0)$ and $(1,1)$. This includes copying the behaviour under $\delta$ and under $F$. 

We preserve the initial state because $\vec{x}_0$ is a selection/construction/algebraic operation, not a dynamics/behavioural/coalgebraic operation. We do not apply transformations to the results of algebraic operations to avoid aggregating the transformation erroneously due to composition of algebraic and coalgebraic operations. Consider the following: the initial state $\vec{x}_0$ is of type $1\rightarrow\vec{X}$ which is algebraic, so the only way to apply $m$ to $\vec{x}_0$ is by composing it on the left, i.e., $m\circ \vec{x}_0(0)$. Checking if the initial state is accepting in the original automaton corresponds to the expression $(F\circ\vec{x}_0)(*)$; however, the expression
\begin{align*}
    (F\circ m)\circ (m\circ\vec{x}_0)(0)= (F\circ m)(1,1)=F(0,0)=0,
\end{align*}
applies $m$ twice, and it fails to properly check if the initial state of the transformed automaton is final. Instead, the correct expression is 
\begin{align*}
    (F\circ m)(\vec{x}_0)= (F\circ m)(0,0)=F(1,1)=1.
\end{align*}
% In other words, since $m(0,0)=(1,1)$, we copy the original behaviour of $(1,1)$ and we give it to $(0,0)$, including that $(1,1)$ is an accepting state; similarly, since $m(1,1)=(0,0)$ we copy the original behaviour of $(0,0)$ to $(1,1)$. 
% We do not change the initial state because 

\begin{figure}[t]
    \centering
    \begin{tikzpicture}
        \node[state] (00) {$(0,0)$};
        \node[state, below right of=00] (01) {$(0,1)$};
        \node[state, above right  of=00] (10) {$(1,0)$};
        \node[state, below right of=10] (11) {$(1,1)$};
        \draw 
        (00) edge[above, bend left, dashed,color=gray] node[color=lightgray]{1} (10)
        (00) edge[loop above, dashed,color=gray] node[color=lightgray]{0} (00)
        % (01) edge[bend left, dashed,color=gray] (10)
        % (01) edge[bend left, below, dotted, color=gray](00)
        % (10) edge[bend left, dashed, color=gray] (11)
        % (10) edge[bend left, right, dotted, color=gray] (01)
        (11) edge[loop above, dashed, color=gray] node[color=lightgray]{1} (11)
        (11) edge[bend left, below, dashed, color=gray]node[color=lightgray]{0} (01)
        %Mutation Arrows
        (00) edge[color=gray, dotted] (11) 
        % (01) edge[color=red,dotted]  (10)
        % (10) edge[color=red, dotted]  (01)
        (11) edge[color=gray, dotted] (00)
        %New arrows
        (00) edge[bend right, below,color=red] node{0} (01)
        (00) edge[bend right, below,color=red] node{1} (11)
        (11) edge[bend right, above,color=red] node{0} (00)
        (11) edge[bend right, above,color=red] node{1} (10)
        % (11) edge[above] node{1} (1,0)
        % (11) edge[bend right, above] node[near start]{0} (00)
        ;\end{tikzpicture}
    \caption{Composition of the fault $m$ and the original behaviour for the states $(0,0)$ and $(1,1)$. The dotted, gray, bidirectional arrow in the centre captures the effect of the fault $m$. The original behaviours appear as dashed, grey lines. The behaviour which results from the composition appears as solid, red lines.}
    \label{fig:ExampleWithFaults}
\end{figure}
We say that the transformed system is \emph{latent} with respect to the original system, since the application of the transformation $m$ creates the new behaviour. In general, we cannot create arbitrary behaviours only through transformations of the state space; e.g., we cannot obtain an automaton that accepts every sequence from a single-state automaton that rejects all sequences by just transforming the state space. 

In the following, we present a general treatment for spatial transformations and latent behaviours in the context of $F$-coalgebras. We describe the limitations on creating new behaviours through  spatial transformations in arbitrary $F$-coalgebras, and we also describe the necessary conditions that lift these limitations.

% To transform an automaton which accepts all sequences into one that can reject some or all, we need a transformation of the \emph{functionality}. 
% Those transformations correspond to the arrow $F(X)\xrightarrow{b}F(X)$ in Figure~\ref{fig:TheArrow}. 
% \todo[inline]{the final coalgebra is the place where spatial, dynamics, and coalgebras meet. Spatial transformations abstract a behaviour acting concurrently with the one we are currently studying, and that's why they are interesting to study.}
%However, systems created by transformations of type $F(X)\xrightarrow{b}F(X)$ are not latent by definition. %In this thesis, we are interested in seeing how far we can go with just carrier transformations; i.e., with latent behaviours.
 
% \todo[inline]{Remark eventually that we cannot model every malicious behaviour of the programmer, only those that affect state, not functionality.}
\section{Latent \texorpdfstring{$F$-coalgebras and Latent Behaviours}{F-coalgebras and Latent Behaviours}}
Given an $F$-coalgebra $(X,c\colon X\rightarrow F(X))$, each state $x\in X$ has an associated dynamics function $c(x)\in F(X)$. In this section, we study the effect of a state transformation $m\colon X\rightarrow X$ over the $F$-coalgebra $(X,c)$, which changes the dynamics of $x\in X$ from $c(x)$ to $c\circ m(x)$. 

In terms of types, we can always compose the function $c$ with any carrier transformation $m$; the composition $c \circ m\colon X\rightarrow F(X)$ exists and is well defined. However, the behaviour of elements might be greatly affected. In particular, states which are bisimilar under $c$ might no longer be bisimilar under $c \circ m$. If $m$ preserves bisimilarity, then we say that $m$ is \emph{sound and consistent}.

\begin{definition}[Sound and Consistent Spatial Transformations]
Given an $F$-co-algebra $(X,c)$, any function of type $m\colon X\rightarrow X$ is a \emph{spatial} \emph{transformation}. %A transformation $m\colon X \rightarrow X$ has \emph{finite support} iff $m(x)\neq x$ only for a finite number of $x\in X$. We denote the set of finitely supported transformations by $X^X_\omega$. 
A spatial transformation $m$ is \emph{sound} if and only if $x\sim_c y$ implies $m(x)\sim_{c} m(y)$, for all $x,y \in X$. Similarly, a spatial transformation $m$ is \emph{consistent} if and only if $m(x)\sim_{c} m(y)$ implies $x\sim_c y$, for all $x,y \in X$. %We denote the set of consistent transformations by $X^X|_\sim$. %
\end{definition}
%Henceforth, we consider only minimal systems, unless explicitly mentioned otherwise. 
\begin{corollary}
    If $(X,c)$ is a minimal $F$-coalgebra, then every spatial transformation %$m\colon X\rightarrow X$ 
    is sound. %  This property also holds if $(X,c)$ is a sound coalgebraic specification language.
\end{corollary}
Applying transformation function $m\colon X\rightarrow X$ in the context of an $F$-coalgebra $(X,c$) changes the normal behaviour of the states in $X$, and it creates the \emph{latent coalgebra of $(X,c)$ under $m$}. 
\begin{definition}[Latent Coalgebra and Latent Behaviour]
Given an $F$-coalgebra $(X,c)$ and a transformation $m$, the \emph{latent coalgebra of $(X,c)$ under $m$} is $(X,c\circ m)$. 
\end{definition}
% \begin{align}
%     \mathbb{X}\circ m\triangleq(X,{(o\circ m, \delta\circ m })).
% \end{align}
% The function $\TheLatentBehaviourOfIn{\cdot}{m}{c}\colon X\rightarrow \sigma F$ defines the \emph{latent behaviour} under $m$. The homomorphism $\TheLatentBehaviourOfIn{\cdot}{m}{c}$ corresponds to the semantic map of the $F$-coalgebra $(X,c\circ m)$; that is, for $x\in X$, 
The semantic map $!_{c\circ m}$ %$\TheBehaviourOfIn{x}{{c\circ m}}$ 
of the latent coalgebra $(X,c\circ m)$ characterises the \emph{latent behaviours} created $m$. 

\begin{example}
\label{ex:Latent:TheExample}
Consider the automaton from Section~\ref{sec:Latent:Motivation} which recognises the language $(0|1)^*11$. Let $F$ be the functor $F(X)=2\times X^2$; we model the automaton with an $F$-coalgebra $(\vec{X},(F,\delta))$, where $\vec{X}=2\times2$ and $(F,\delta)\colon X\rightarrow 2\times X^2$ is a function pair, defined for $(x,y)\in \vec{X}$ by
\begin{align}
    F(x,y)&\triangleq x \land y\\
    \delta(x,y)(i)&\triangleq (i,x).
\end{align}
Just like its automaton counterpart, this $F$-coalgebra is not minimal, since $(0,0)$ and $(0,1)$ are bisimilar
There are $|X|^{|X|}=256$ different spatial transformations, but that does not imply the existence of 256 different latent coalgebras; e.g., the transformations $\Delta_{(0,0)}$ and $\Delta_{(0,1)}$ which respectively map all states to $(0,0)$ and $(0,1)$ yield isomorphic latent coalgebras, since $(0,0)$ and $(0,1)$ are bisimilar; both of these latent coalgebras recognise the empty language starting in all states. 
The transformation $m(x,y)=(\lnot x,\lnot y)$ creates the latent coalgebra where 
\begin{align}
    (F\circ m)(x,y)&= \lnot x \land \lnot y\\
    (\delta\circ m)(x,y)(i)&= (i,\lnot x).
\end{align}
The behaviour of a state $x$ changes when $m$ acts on $x$. In particular, the behaviour of state $(0,0)$ is the language $(0|1)^*11$, but its latent behaviour under $m$ is the language $\varepsilon|(0|1)^*10$.
\end{example}
% \todo[inline]{There is no notion of distance or how different behaviours are in this setting. Things either are equal/isomorphic or they are not.}
\section{Latent Behaviour Analysis}
LBA is the study of the effects that a spatial transformation $m\colon X\rightarrow X$ has over the behaviour of states in $X$ in the context of an $F$-coalgebra $(X,X\xrightarrow{c} F(X))$. We use LBA to understand the behavioural changes that the system $(X,c)$ undergoes due to the application of the transformation $m$, as illustrated by the following example.
\begin{example}
    In the context of Example~\ref{ex:Latent:TheExample}, consider the behavioural property $Q\colon 2^{2^*}\rightarrow 2$, where, $\phi \in 2^{2^*}$, $Q(\phi)$ is true if and only if $\phi\subseteq \varepsilon | (0|1)^*1$, i.e., if $\phi$ accepts a sequence $w\in 2^*$, then $w$ ends in 1 or $w$ is empty. 

   All states in $2\times 2$ satisfy the property $Q$ in the original $F$-coalgebra since both $(0,0)$ and $(1,0)$ recognise the language $(0|1)^*11$, the state $(0,1)$ recognises the language $(0|1)^*1$, and $(1,1)$ recognises $\varepsilon + 0(0|1)^*11 + 1(0|1)^*1$. 
   However, in the latent coalgebra created by $m$, which maps $(a,b)$ to $(\lnot a, \lnot b)$, the state $(0,0)$ now recognises the language $\varepsilon|(0|1)^*10$, so it no longer satisfies the behavioural property $Q$.

    We can repair the system with respect to the property $Q$ if we use $m$ again in the latent coalgebra $(2\times 2, c\circ m)$ to create the latent coalgebra $(2\times 2, c\circ m\circ m)$ as $m \circ m=\id$. Thus, if $m$ is an attack, then a second application of $m$ is a valid counterattack with respect to $Q$. 
    %since the behavioural properties of $(2\times 2, c\circ m\circ m)$ are the same as those of the original system $(2\times 2, c)$. 
    % but only when the latent coalgebra $(2\times 2, c\circ m)$ has been created (otherwise, the application of $m$ creates $(2\times 2, c\circ m)$, and it breaks $Q$).
\end{example}

Our choice to focus on spatial transformations may seem arbitrary since it is also possible to affect the behaviour of states by composing $c$ with a {dynamics transformation} $b\colon F(X)\rightarrow F(X)$ to obtain the new dynamics function $b \circ c$, as in the "Arrow" in Figure~\ref{fig:TheArrow}. %Both $(X,b\circ c\colon X\rightarrow F(X))$ and $(X,b\circ c\circ m\colon X\rightarrow F(X))$ are $F$-coalgebras, since the type requirement is satisfied. 
However, there are systems for which spatial and behavioural transformations can create the same behaviours; moreover, we can create any arbitrary behaviours via spatial transformations: \emph{final $F$-coalgebras}, and \emph{sound and complete coalgebraic specification languages}.

%\subsection{Latent Coalgebras of Final $F$-coalgebras}
A final $F$-coalgebra $(\sigma F, 1_F)$ has a dynamics function $1_F\colon \sigma F \rightarrow F(\sigma F)$ that is an isomorphism. Since $\sigma F \simeq F(\sigma F)$, it naturally follows that 
\begin{align}
    \sigma F\rightarrow \sigma F \simeq \sigma F\rightarrow F(\sigma F) \simeq F(\sigma F)\rightarrow F(\sigma F).    
\end{align}
In other words, in the carrier of the final $F$-coalgebra, spatial transformations (of type $\sigma F\rightarrow \sigma F$), dynamics transformations (of type $F(\sigma F)\rightarrow F(\sigma F)$) and $F$-coalgebras (of type $\sigma F\rightarrow F(\sigma F)$) are in a one-to-one correspondence. 

Intuition tells us that $1_F\colon \sigma F \rightarrow F(\sigma F)$ should correspond to $\id_{\sigma F}\colon \sigma F\rightarrow \sigma F$ and should correspond to $\id_{F(\sigma F)}\colon F(\sigma F)\rightarrow F(\sigma F)$. The general correspondence is given by the following proposition.
\begin{proposition}
    For every $F$-coalgebra $(\sigma F, c)$, there are transformations $m\colon \sigma F\rightarrow \sigma F$ and $b\colon F(\sigma F)\rightarrow F(\sigma F)$ such that the diagram in Figure~\ref{fig:FinalEquivalence} commutes.
\end{proposition}
\begin{proof}
    Since $1_F\colon \sigma F\rightarrow F(\sigma F)$ is an isomorphism, by taking $m=1_F^{-1}\circ c$ and $b=c\circ 1_F^{-1}$, the diagram in Figure~\ref{fig:FinalEquivalence} commutes.
\end{proof}
\begin{corollary}
    Every $F$-coalgebra $(\sigma F, c)$ is a latent coalgebra of $(\sigma F, 1_F)$ under some spatial transformation $m\colon \sigma F\rightarrow \sigma F$.
\end{corollary}

\begin{figure}[t] 
    \centering
    \begin{tikzcd}[column sep=1.5cm, row sep=1.5cm]
         \sigma F
            \arrow[r,"m"]
            \arrow[dr,"c"]
            \arrow[d,"1_F"']
        &\sigma F
            \arrow[d,"1_F"]
        \\
         F(\sigma F)
            \arrow[r,"b"']
        &F(\sigma F)
            %\arrow[u,"1^{-1}"']
    \end{tikzcd}
    \caption{Every $F$-coalgebra $(\sigma F, c)$ can be created from the final coalgebra $(\sigma F,1_F)$ by means of a transformation $m$ or a transformation $b$. In other words, it suffices to use spatial transformations $m$ and the final $F$-coalgebra to create all $F$-coalgebras of $\sigma F$, so dynamics transformations $b$ are unnecessary.}
    \label{fig:FinalEquivalence} 
\end{figure}
This property applies to the carrier of the final coalgebra because of the reversibility of the final dynamics map $1_F$, which formalises a correspondence between state and behaviour. This property is also shared by sound and complete coalgebraic specification languages, since their semantic map is an epimorphism. For an arbitrary $F$-coalgebra $(X,c)$, only some latent $F$-coalgebras can be created by spatial transformations $m\colon X\rightarrow X$. It would not be an exaggeration to state that $F$-coalgebras which satisfy this property have all the "necessary gadgets" (with respect to the functor $F$) to create any arbitrary functionality using spatial transformations. 

%\subsection{$F$-Coalgebras as Endofunctions}
Given a final $F$-coalgebra $(\sigma F, 1_F)$ and an arbitrary coalgebra $(\sigma F, c)$, the spatial transformation $\omega\colon \sigma F\rightarrow \sigma F$, defined by $\omega\triangleq 1_F^{-1}\circ c$, implements $c$. The identity spatial transformation implements $1_F$. This duality between $F$-coalgebras and spatial transformations in $\sigma F$ enables a natural composition of $F$-coalgebras in $\sigma F$.
%This treatment simplifies the composition of $F$-coalgebras in $\sigma F$. 

%When we compose $F$-coalgebras we are applying their behaviour functions sequentially. 
Given two $F$-coalgebras $(\sigma F, c_1)$ and $(\sigma F, c_2)$ whose respective spatial transformation implementations are $\omega_1$ and $\omega_2$, the composition $\omega_2\circ \omega_1$ gives rise to the following equivalent concepts:
\begin{itemize}
    \item the $F$-coalgebra $(\sigma F, c_2\circ 1_F^{-1}\circ\omega_1)$,
    \item the latent coalgebra of $(\sigma F, c_2)$ under $\omega_1$,
    \item the latent coalgebra of $(\sigma F, 1_F)$ under $\omega_2\circ \omega_1$.
\end{itemize}
In summary, we can represent $F$-coalgebras whose carrier is $\sigma F$ by endofunctions in $\sigma F$, and we can reason about their composition as we would with functions in the monoid of endofunctions $(\sigma F\rightarrow \sigma F, \circ, \id)$. 

% \todo[inline]{Explain that this corresponds to the point of The Arrow: $!c$ takes you from $X$ to $\sigma F$, and you can use $\omega$ to create a latent coalgebra of $(\sigma F, 1)$. This arrow $\omega$ implements the behavioural change from $!c$ to $!_{b\circ c\circ m}$.}
In the following, we return to arbitrary $F$-coalgebras $(X,c)$, but we keep in mind the following: when we create a latent coalgebra of $(X,c)$ under a spatial transformation $m$, we are implicitly sequentially composing the behaviour function $c$ with the behaviour function of the $F$-coalgebra implemented by $m$; first we apply $m$ and then we apply $c$.

\section{Some Applications of Latent Behaviour Analysis}
% \todo[inline]{Describe in terms of coalgebras an introduction for the three application topics we have: attacker model classification, CPS redesign and Side-channel repair.}
We study the effects that spatial transformations have on the behaviour of the system. Just like in geometry, some spatial transformations may preserve some properties of the system, while others may break them. In this section, we present three ideas for LBA to study four aspects of systems: \emph{formalisation of integrity attackers}, \emph{quantifying and improving robustness}, \emph{classification of attacker models}, and \emph{side-channel repair}.



% Consider the system from Section~\ref{sec:Latent:Motivation} and it coalgebraic equivalent presented in Example~\ref{ex:Latent:TheExample}. This example has 256 different spatial transformations, which affect the system in different ways. 
% \todo[inline]{I dunno where I was going with this}

% {\color{blue} Working with endofunctions is nice because you can study e.g. those with finite support. Endofunctions with finite support finitely compose nicely, and you can use them to model incremental changes to behaviour.

% What I need to do though is to hint towards potential applications. This section describes that in final coalgebras it suffices to compose endofunctions to model behaviours. In arbitrary coalgebras however, we can 
% }
% Composition of $F$-coalgebras is non-commutative. 
% \begin{theorem}[Fundamental Theorem of Latent Behaviour Analysis]
%     \label{theo:Fundamental}
%     The semantic map-ping of the $F$-coalgebra $(X,c\circ m\colon X\rightarrow F(X))$ factors through the semantic map of the $F$-coalgebra $(m(X),c\colon m(X)\rightarrow F(m(X)))$
%     \todo[inline]{This probably needs to use bounded functors.}
% \end{theorem}
%This composition is in general not commutative.

% Consider an example in automata: we define $m\colon \sigma F\rightarrow \sigma F$ such that 
% \begin{align*}
%     m(\phi)(w)=
% \begin{cases}
%     \phi(w), \quad \text{if $w$ ends in 1},\\
%     0,\quad \text{otherwise}.
%     % \lnot \phi(w), \quad \text{if $w\varepsilon$}\\
%     % \phi(w), \quad \text{otherwise}.
% \end{cases}
% \end{align*}
% In other words, $m$ removes all sequences that do not end in $1$ from the language characterised by $\phi$. We obtain $c=1\circ m$

% In the case of automata, what does it mean for $c(L)=L'$ Normally what we have is $L\mapsto (0|1, 0\mapsto L_0, 1\mapsto L_1)$. 

% \todo[inline]{Something is not right: In the case of automata, }


% , and such a set of created behaviours is determined by the available \emph{gadgets}.

% \section{Gadgets}
% In the context of return-oriented programming~(\cite{ROP}), a \emph{gadget} is a code snipped that is part of the original program, and it is exploited by attackers to hijack the control flow once they affect the return addresses of functions. In the context of LBA, given an $F$-coalgebra $(X,c)$, if $c$ defines the program, then the components of $c$ define the set of \emph{gadgets} we can use to change the behaviour of the system.
% \begin{definition}[Gadgets]
%     Let $\mathbb{X}=(X,c)$ be an $F$-coalgebra. 
%     A \emph{gadget of $\mathbb{X}$} is a pair $(x,c)$ where $x\in X$. %The set of \emph{gadgets of $\mathbb{X}$} by the graph of $c$. 
% \end{definition}

% A gadget $(x,c)$ is a behavioural building block. We can interpret the gadget $(x,c)$ as the action of applying $c$ at $x$, so $(m(x),c)$ models the action of applying $c$ to $m(x)$. 

% In the example presented in Section~\ref{sec:Latent:Motivation}, there are four gadgets. Each gadget gives each spatial transformation $m$ a chance to further alter the behaviour of the system. 
% \todo[inline]{Where do you want to go with this? It looks interesting, but not useful. }

% In the following, we work on arbitrary $F$-coalgebras $(X,c)$ and only consider spatial transformations to

% \todo[inline]{If we want $a$ to change with time there is no need to do anything fancy! We can enhance the carrier by doing $X'=X\times \mathbb{N}$ or $X'=X\times [X\rightarrow 2]$; with this, $X$ is enhanced by a natural number counter or a set of conditions to make the dynamics of the transformation coalgebra more interesting. Maybe there is even no need to do changes, it all depends on how informative $X$ is. let's see}

% \todo[inline]{This means that the problem becomes a "searching for the next candidate at every step" problem. Alternatively, you could learn to compose solutions too. }
% \todo[inline]{Maybe we can also do something exciting: eventuality -> at some point in time, the behaviour you want becomes apparent, i.e. $\TheBehaviourOf{x_0}^w=\rho$ for some $w$}

\subsection{Formalisation of Integrity Attacks and Attacker Models}
\label{sec:Latent:AttackerModels}
LBA studies the effect of spatial transformations. Henceforth, when we refer to an attack, we implicitly mean a spatial transformation. In the particular case of final $F$-coalgebras, their spatial transformations attacks coincide with their dynamics transformations. 

\subsection{Classification of Attackers}
\label{sec:Latent:Classification}
In Chapters~\ref{ch:Classification} and ~\ref{ch:CPSRobustness}, we compare and classify attackers based on their model. The intuition is the following: given an $F$-coalgebra $(\vec{X},c)$ where $\vec{X}$ is a product type of finite types whose coordinates are $\Pi=\set{\pi_1,\ldots,\pi_p}$, and a list of requirements $\mathcal{R}=\set{R_1, \ldots, R_n}$, we can systematically generate attacker models by choosing a subset of coordinates in $\Pi$. Under this formulation, the set of attacker models is characterised by $\ThePowersetOf{\Pi}$. Since attacker models are characterised by sets, we can compare them via set inclusion. This comparison sorts attackers by \emph{capabilities}; i.e., it classifies attackers with respect to the ways they can interact with the system. Then, using LBA, we obtain the set of requirements $\AsSequence{\alpha}[\mathcal{R}]$ broken by attackers fitting the model $\AsSequence{\alpha}$, and we compare these sets of requirements by set inclusion to compare attacker models by their \emph{power}; i.e., for two attacker models $\AsSequence{\alpha}$ and $\AsSequence{\beta}$, if $\AsSequence{\alpha}[\mathcal{R}]\subset \AsSequence{\beta}[\mathcal{R}]$, then $\AsSequence{\beta}$ breaks strictly more requirements than $\AsSequence{\alpha}$, making attackers which fit the model $\AsSequence{\beta}$ more dangerous adversaries than those which fit the model $\AsSequence{\alpha}$.%The attacker model corresponding to $\emptyset$ is the passive attacker, and the attacker 


\subsection{Quantifying and Improving Robustness}
\label{sec:Latent:Robustness}
%Informally, the robustness of a system quantifies how much stress the system can withstand without compromising its functionality. We explore the idea of modelling stress via state-based attacks and how we can quantify and improve the robustness of a system by studying properties of latent coalgebras.

%Formally, w
Let $\mathcal{R}=\set{R_1, \ldots, R_n}$ be a set of behavioural properties that describes both functional and security requirements of a system defined by an $F$-coalgebra $(X,c)$ with an initial state $x_0\in X$, and let %and a set of behavioural properties $\mathcal{R}=\set{R_1, \ldots, R_n}$ and
$m\colon X\rightarrow X$ be a spatial transformation that implements an attack or a fault; informally, %Normally, we would check if $x_0$ satisfies all behavioural properties in $\mathcal{R}$, but now 
we say that the system $(X,c)$ is \emph{robust} with respect to $m$ if $x_0$ still satisfies all the properties in $\mathcal{R}$ despite the effects of the spatial transformation $m$. To check for robustness with respect to $m$, we 
%we might think that it suffices to check $(R_i\circ !_c)(m(x_0))=1$ for each requirement $R_i$, but that is incorrect: the expression $(R_i\circ !_c)(m(x_0))=1$ only checks if the effect of $m$ on the initial state is enough for $R_i$ to fail, and it ignores the effect of $m$ on the rest of the states. The correct way is to 
create the latent coalgebra $(X, c\circ m)$ and check if this new system satisfies all the behavioural properties in $\mathcal{R}$ using standard verification and  testing techniques. 
{%\color{red}
% as illustrated by the following example.
% \begin{example}[Faulty Verification]
%     In the context of Example~\ref{ex:Latent:TheExample}, the functor is $F(X)=2\times X^2$, and it has a final $F$-coalgebra $(2^{2^*},(\varepsilon?,(\cdot)'))$ where $\varepsilon? \colon 2^{2^*}\rightarrow 2$ checks whether the empty sequence $\varepsilon$ belongs to the language and $(\cdot)'\colon 2^{2^*}\rightarrow (2\rightarrow {2^{2^*}})$ computes the Brzozowski derivative~\cite{BrzozowskiDerivative} of the language.  
%     %\todo[inline]{Maybe move to preliminaries?}

%     Let $R\colon 2^{2^*}\rightarrow 2$ be the behavioural property defined by $R(\phi)\triangleq \phi \sim \varepsilon|(0|1)^*10$, for $\phi \in 2^{2^*}$. The property $R$ is not satisfied by any state of the original $F$-coalgebra, so $(R\circ !_c)(m(x_0))$ would be 0 for all spatial transformations $m$; nevertheless, $R$ is satisfied by $x_0$ in the latent coalgebra created by the spatial transformation $m(x,y)=(\lnot x, \lnot y)$ used in Example~\ref{ex:Latent:TheExample}, since it is the language the state $(0,0)$ recognises in the latent coalgebra. 
% \end{example}
%Part of the novelty of LBA is that we can study a latent coalgebra $(X, c\circ m)$ just as we would study the original coalgebra $(X, c)$. By this, we mean that we can apply testing and verification techniques without complication. 
% In the following, we illustrate how we can use spatial transformations to model attacks which target the state of systems rather than the program, and we study the details of this approach in Chapter~\ref{ch:CPSRobustness} when we apply it to cyber-physical systems.


%We know that an attack $m$ creates a latent coalgebra $(X, c\circ m)$ which may or may not satisfy the same behavioural properties that $(X, c)$ satisfies. We could check whether $(X,c\circ m)$ satisfies all requirements in $\mathcal{R}$, but this is not very informative if we arbitrarily choose $m$. 
To quantify the robustness of a system, we systematically generate a set of spatial transformations $\mathcal{M}=\set{m_1,\ldots, m_p}$ based on an attacker model, and we test whether each created latent coalgebra $(X, c\circ m_i)$ satisfies each requirement $R_j$ for $m_i\in \mathcal{M}$ and $R_j\in \mathcal{R}$. If a requirement $R$ is not satisfied in some latent coalgebra $(X, c\circ m)$, then the attacker can use $m$ to break $R$ in the original system $(X,c)$; in this case, we say that \emph{the attack $m$ breaks the requirement $R$}. %If no attack in $\mathcal{M}$ breaks any requirement in $\mathcal{R}$, then we say that the system is \emph{robust} against the attacker model that generated $\mathcal{M}$. This approach gives us a qualitative notion of robustness.

% We can extend qualitative robustness into quantitative robustness by discounting broken requirements. More precisely, given $(X,c)$, $\mathcal{M}$, and $\mathcal{R}$ such that $|\mathcal{R}|=n$, we can define the set $\mathcal{M}[\mathcal{R}]$ of requirements in $\mathcal{R}$ that are broken by one or more attacks in $\mathcal{M}$; similarly $m[\mathcal{R}]$ is the set of requirements that $m$ breaks. We estimate the robustness of the system by the formula 
% \begin{align*}
%     \sum_{i=i}^n{w_i(1-(R_i\in \mathcal{M}[\mathcal{R}]))},
% \end{align*}
% where $w_i\in \mathbb{R}^+$ is a weight which implements the importance of requirement $R_i$.

%Let us consider the case where $(X,c)$ fails a non-empty set of requirements; this set, given the definitions, is equal to $\id[\mathcal{R}]$. Now, let $\mathcal{K}=\set{k_1, \ldots, k_q}$ be an arbitrary set of spatial transformations independent of $\mathcal{M}$; 
Spatial transformations can be used to repair systems as well. Given a set of spatial transformations $\mathcal{K}=\set{k_1,\ldots, k_q}$, we say that $k\in \mathcal{K}$ \emph{repairs $(X,c)$} with respect to a property $R$ if $(X,c)$ does not satisfy $R$ but $(X,c\circ k)$ does. The set $\mathcal{M}$ and $\mathcal{K}$ are both sets of spatial transformations, but the former describes an attacker model, while the latter describes a counterattacker model.
%  requirements satisfied by %$k[\mathcal{R}]\subset \id[\mathcal{R}]$; 
% we say that $k$ \emph{fully repairs $(X,c)$} if $k[\mathcal{R}]$ is empty. 

% Dual to attackerspatial transformations $\mathcal{K}$ corresponds to a repair toolkit, which we generate systematically just like we did with the set of attacks $\mathcal{M}$.
We study the process of system repair in more detail in Chapters~\ref{ch:CPSRobustness}.~\ref{ch:SideChannelRepair}.

% We now consider an analysis that combines both $\mathcal{M}$ and $\mathcal{K}$ as follows: if an attack $m\in \mathcal{M}$ breaks some requirements, is there a \emph{counterattack} $k$ that fully repairs $(X,c\circ m)$? If so, we can improve the robustness of the system $(X,c)$ by transforming it into $(X,c\circ m \circ k)$ whenever we detect that the attack $m$ is affecting $(X,c)$; we refer to this dependent notion of robustness as \emph{latent robustness}, 

% Given an attacker model which generates the set of attacks $\mathcal{M}$, 

% Considering that latent coalgebras are coalgebras, we could apply LBA to latent coalgebras. 

% There are two dimensions we can explore: one, given $(X, c)$ and $m$, we can iterate over $\mathcal{R}$ and check whether $(X,c)$ and $(X,c\circ m)$ satisfy $R$ for $R\in \mathcal{R}$, or two, given $(X,c)$ and $\mathcal{R}$
% % Different $F$-coalgebras have different sets of attacks. In our framework, a minimal $F$-coalgebra $(X,c)$ has as many attacks as $|X|^{|X|}$.


\subsection{Side-Channel Repair}
The last application of LBA that we consider is of program repair. We briefly mentioned the idea in Section~\ref{sec:Latent:Robustness}: given an $F$-coalgebra $(X,c)$ and a set of requirements $\mathcal{R}=\set{R_1, \ldots, R_n}$, if $\AsSequence{\emptyset}[\mathcal{R}]$ is non-empty (i.e. the system fails some requirements), then we can look for spatial transformations to create a latent behaviour $(X,c\circ m)$ such that $\set{m}[\mathcal{R}]$ is empty. We consider an interesting case where the state $x$ is a program, and $R$ consists of a single requirement: constant memory access patterns. We propose an idempotent spatial transformation $\mathcal{O}$ which maps $x$ to a state which satisfies constant memory access patterns. In Chapter~\ref{ch:SideChannelRepair}, we show how we can use $\mathcal{O}$ to repair a family of timing side-channel leaks for LLVM programs.

\section{The Arrow: a Summary of LBA}
%We summarise the idea behind LBA using the Arrow. 
Normally, for a functor $F$ that has a final $F$-coalgebra $(\sigma F, 1_F)$, any $F$-coalgebra $(X,c)$ satisfies the commutative diagram in Figure ~\ref{fig:SemanticsMap}. 
When we compose a function $m\colon X\rightarrow X$ on the right of $c$ and a function $b\colon F(X)\rightarrow F(X)$ on the left of $c$, we obtain the pair $(X,b\circ c\circ m)$, which is an $F$-coalgebra. Since $(X,b\circ c\circ m)$ is an $F$-coalgebra, it has its own diagram similar to the one in Figure~\ref{fig:SemanticsMap} exists, replacing $c$ by $b\circ c\circ m$. However, the relation between the semantic maps $!_{c}$ and $!_{b\circ c\circ m}$ is not so simple: in general, the semantic map $!_{b\circ c\circ m}$ is not equal to the function $(!_{b\circ c})\circ m$, so we cannot directly lift the effects of a given spatial transformation $m$ to the behaviours of an $F$-coalgebra. At best, if $m$ is sound, then we can create a map $\omega\colon \sigma F\rightarrow \sigma F$ that maps the old behaviours of the system to the new ones created by $m$. 

This impossibility to soundly lift the effects of $m$ in $X$ to a function in $\sigma F$ indicates that, in general, we cannot deduce properties of latent coalgebras from their original systems, and we should study latent coalgebras as if they were independent systems. However, the properties proved in latent coalgebras act as a proof of behavioural properties of their original systems, as we show in the following chapters. For example, an $F$-coalgebra $(X,c)$ is robust with respect to a behavioural property $Q$ and a set of spatial transformations $M$ if, for all $m\in M$, the latent coalgebra $(X,c\circ m)$ satisfies the behavioural property $Q$.

\begin{figure}[t]
\centering
\begin{tikzcd}[column sep=3cm, row sep=2cm]
    X
        \arrow[r,dotted, "!_{c}"]
        \arrow[d,"c"] 
    &\sigma F 
        %\arrow[dd, "\simeq","\omega"']
        \arrow[d, "\simeq"',"1_F"]
    \\
    F(X)
        \arrow[r, dotted, "F(!_{c})"] 
    &
    F(\sigma F)
\end{tikzcd}
\caption{Typical commuting diagram for the semantic map $!_c$ in universal coalgebra.}
\label{fig:SemanticsMap} 
\end{figure}
% Consider the following definition of \emph{arbitrary state-based attacks}.
% \begin{definition}[Arbitrary State-based Attack]
%     \label{def:Latent:StateAttacks}
%     Given an $F$-coalgebra $(X,c)$, the set of its \emph{state-based attacks} is the set of its spatial transformations, i.e., $X^X$. 
%     %We also define the set of its \emph{behaviour-based attacks} by $F(X)^{F(X)}$. 
%     \end{definition}
% Under this definition,
% \todo[inline]{Explain the arrow}

\section{Related Work}
The theory of LBA stems from universal coalgebra~\cite{UniversalCoalgebra}. The use of the theory of coalgebras has rapidly grown in the past decade, and has found notorious applicability in the domain of program semantics~\cite{GKAT,GKATCoequations}. However, the theory of coalgebras mainly focuses on the correctness and functionality of systems, dismissing the security problem a dual of correctness~\cite{JacobsBook}; more precisely, if correctness is the description of desired behaviour, then security is the description of undesired behaviour. This view unfortunately restricts attackers of coalgebras to be external actors that can only interact with the system via clearly defined interfaces. In other words, the user of the system modelled by the coalgebra is the attacker, and only the user can be the attacker. Our proposal of modelling attackers as sets of spatial transformations gives us more flexibility when describing the effects of attackers, while still retaining compatibility with the theory of coalgebras. By modelling an attack as a spatial transformation $m\colon X\rightarrow X$ acting on an $F$-coalgebra $(X,c)$, we naturally incorporate the effects of the attack into the behaviour of the coalgebra. 



% \todo[inline]{Complete this to put LBA in the context of coalgebras}
% While this view is sufficient to capture the intuition of attackers and their effects 

% Thanks to its generality, it is possible to provide w

% We now discuss related work regarding the motivation presented in this chapter and the theory presented in Chapter~\ref{ch:LatentBehaviours}. Each chapter on the applications module, i.e. Chapters contains its own related work section.
% \todo[inline]{Small introduction to the works mentioned before in coalgebra and some works that use coalgebra and security, like the one that Jorge told me...}