%!TEX root = ../main.tex
% Chapter Template


\chapter{Foundations of Latent Behaviour Analysis} % Main chapter title
\label{ch:LatentBehaviours} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}
% \todo[inline]{Find a suitable quote?}
% \begin{quote} 
%     "If you only do what you can do, you will never be more than what you are now." -- Master Shifu.
% % "As you adequately put, the problem is choice. But we already know what you are going to do, don't we?" -- The Architect.
% \end{quote} 

\section{Introduction}
 
A \emph{latent behaviour} is a functionality that is not coded into a system, so the system normally does not display it, but given extraordinary circumstances, the system displays such functionality. To reveal a latent behaviour, we transform the state space of the system. Normally, the state space is not transformed, so we can model "extraordinary circumstances" using these transformations. This concept is probably well illustrated by \emph{return-oriented programming} (ROP) as described in~\cite{ROP}, where the state of the call stack is transformed to alter the behaviour of the program being executed, but the program itself is not modified.

In ROP, the adversary manipulates the call stack to string code gadgets together and arbitrarily execute code. However, if the program is very small and does not have enough gadgets, then the computational power of the attacker is restricted, since it becomes impossible to create certain behaviours. This restriction is similar to the restrictions we face when working with non-Turing complete languages (e.g., we cannot use regular expressions to specify arbitrary Turing machines). However, given enough gadgets, we can reveal any behaviour we want if we appropriately compose the gadgets.

In this section, we explain the commutative diagram presented in Figure~\ref{fig:TheArrow}. This diagram, which we refer to as the ``Arrow" of latent behaviour analysis, illustrates how spatial and dynamics transformations affect the behaviour of an arbitrary $F$-coalgebra $(X,c)$ by changing the semantic map from $!_c$ to $!_{b\circ c\circ m}$. The intuition behind the diagram of the Arrow is the following. Normally, an $F$-coalgebra $(X,c)$ gives semantics to the elements in $X$ via the semantic map $!_c$. When affected by a spatial transformation $m\colon X\rightarrow X$ and a dynamics transformation $b\colon F(X)\rightarrow F(X)$, the $F$-coalgebra $(X,c)$ reveals an $F$-coalgebra $(X,b\circ c\circ m)$. The behaviour of elements in $(X,b\circ c\circ m)$ may bear no resemblance to the original behaviour. At most, we can say that if $m$ and $b$ preserve bisimilarity, then there exists a transformation $\omega\colon \sigma F \rightarrow \sigma F$ in the carrier of the final $F$-coalgebra $(\sigma F, 1)$ which maps the original behaviours of the system into the new behaviours revealed by $m$ and $b$. 

\begin{figure}[h]
        \centering
        \begin{tikzcd}[column sep=1.75cm, row sep=1cm]
            &\sigma F
                \arrow[dr,swap,"\omega"']
            &
            \\ 
            X  
                \arrow[dd,"c"] 
            & X
                \arrow[l, swap, "m"]
                \arrow[u, "!_{c}"]
                \arrow[r,dotted, swap, "!_{b\circ c\circ m}"]
            &\sigma F 
                %\arrow[dd, "\simeq","\omega"']
                \arrow[dd, "1_F"]
                \arrow[dr, "\textbf{id}"]
            \\
            &&&\sigma(F)
            \\
            F(X)     
                \arrow[r, swap, "b"]
            &F(X)
                \arrow[d, swap, "F(!_{c})"]
                \arrow[r, dotted, "F(!_{b\circ c\circ m})"] 
            &
            F(\sigma F)
                %\arrow[ur, swap, "\omega^{-1}"]
                \arrow[ur, swap, "1_F^{-1}"]
            \\
            &F(\sigma F)
                \arrow[ru, swap, "F(\omega)"]
            &
        \end{tikzcd}
        \caption{``The Arrow of Latent Behaviour Analysis.'' This commutative diagram summarises the effect of spatial and dynamics transformations over the $F$-coalgebra $(X,c)$, respectively modelled by $m$ and $b$: the semantic map changes from $!_c$ to $!_{b\circ c\circ m}$. Through this work, we assume $b=\id$.}
        \label{fig:TheArrow} 
    \end{figure}

%\section{Motivational Example: Modelling Faults with Spatial Transformations}
\section{Motivational Example}
\label{sec:Latent:Motivation}
% \todo[inline]{Small intro to transformed systems. You should have mentioned already somewhere in the intro that there are two ways to mutate the behaviour of a system in the coalgebra world: by transforming the carrier or by transforming the co-carrier. We only study transformations of the carrier.}
% \todo[inline]{I feel like we are missing some stuff? How are we going to structure the introduction?}
Consider the automaton shown in Figure~\ref{fig:ExampleLatent}, which recognises the language of sequences in $2^*$ that end in two consecutive 1; i.e., the language $(0|1)^*11$. 
This automaton is defined by the tuple $(\vec{X},\vec{x}_0,\delta,F)$; the carrier is $\vec{X}\triangleq2\times2$, the initial state selector is $\vec{x}_0\colon1\rightarrow \vec{X}$ with $\vec{x}_0(0)\triangleq(0,0)$, the transition function is $\delta\colon \vec{X}\rightarrow 2\rightarrow\vec{X}$, defined for $\vec{x}\in \vec{X}$ and $i \in 2$ by $\delta(\vec{x})(i)\triangleq(i,\vec{x}[0]),$ and the characteristic predicate of the set of accepting states is $F\colon\vec{X}\rightarrow 2$, where $F(x,y)\triangleq x \land y$
%$F(1,1)\triangleq1$ and $F(x,y)\triangleq0$ otherwise
(i.e. $(1,1)$ is the only accepting state). This automaton is not minimal, since the states $(0,0)$ and $(0,1)$ are different, yet they are bisimilar.

\begin{figure}[t]
    \centering
    \begin{tikzpicture}
        \node[state,initial] (00) {$(0,0)$};
        \node[state, below right of=00] (01) {$(0,1)$};
        \node[state, above right  of=00] (10) {$(1,0)$};
        \node[state, accepting, below right of=10] (11) {$(1,1)$};
        \draw (00) edge[bend left, above] node{1} (10)
        (00) edge[loop above] node{0} (00)
        (01) edge[bend left, left] node{1} (10)
        (01) edge[bend left, above] node{0} (00)
        (10) edge[bend left, above] node{1} (11)
        (10) edge[bend left, right] node{0} (01)
        (11) edge[loop above] node{1} (11)
        (11) edge[bend left, above] node{0} (01)
        ;\end{tikzpicture}
    \caption{An automaton which recognises the language $(0|1)^*11$.}
    \label{fig:ExampleLatent}
\end{figure}

Now, consider a transformation %assume that the programmer is malicious, and they purposely 
% consider a transformation $m\colon \vec{X}\rightarrow\vec{X}$ which maps $(a,b)\in \vec{X}$ to $(\lnot a, \lnot b)$. 
$m\colon \vec{X}\rightarrow\vec{X}$, defined by $m(\vec{x})\triangleq(\lnot \vec{x}[0],\lnot \vec{x}[1])$ for $\vec{x}\in \vec{X}$; i.e., $m$ maps $(a,b)$ to $(\lnot a, \lnot b)$. This transformation models some fault which could be introduced by a malicious programmer or by an attacker which corrupts the state of the system. Due to this transformation, %e compute state transformations before computing the behaviour; thus, 
if the current state is $\vec{x}=(a,b)$, when we intend to check whether $\vec{x}$ is accepting, we check whether $(\lnot a, \lnot b)$ is accepting instead, and when we intend to compute $\delta(\vec{x})(i)$, we instead compute $\delta(\lnot a, \lnot b)(i)$. 
\begin{figure}[t]
    \centering
\begin{tikzpicture}
    \node[state, initial, accepting] (00) {$(0,0)$};
    \node[state, below right of=00] (01) {$(0,1)$};
    \node[state, above right  of=00] (10) {$(1,0)$};
    \node[state, below right of=10] (11) {$(1,1)$};
    \draw (00) edge[bend right, above] node{1} (11)
    (00) edge[bend right, above] node{0} (01)
    (01) edge[bend right, above] node{1} (11)
    (01) edge[loop below] node{0} (01)
    (10) edge[loop above] node{1} (10)
    (10) edge[bend right, above] node{0} (00)
    (11) edge[bend right, above] node{1} (10)
    (11) edge[bend right, above] node{0} (00)
    ;\end{tikzpicture}
\caption{Automaton that models the transformed automaton, which now recognises $\varepsilon|(0|1)^*10$.}
\label{fig:Transformed}
\end{figure}

Figure~\ref{fig:Transformed} shows a model of the transformed automaton. This automaton recognises the language of sequences that are either empty or end in 10; i.e., $\varepsilon|(0|1)^*10$. 
Before we explain why the automaton in Figure~\ref{fig:Transformed} is in fact the resulting system when we apply the transformation $m$, we can first test if the transformed system recognises sequences $\varepsilon|(0|1)^*10$ due to the transformation $m$. %$(0|1)(0|1)^*$. 
To do so, let us consider pairs of states $[\vec{x},\vec{y}]$ where $\vec{x}=(x_1,x_2)$ and $\vec{y}=(y_1,y_2)$ such that the pair $\vec{x}$ follows the original behaviour while $\vec{y}$ follows the new behaviour. 
Let $[(0,0),(0,0)]$ be the initial state, and let $\delta_i\colon \vec{X}\rightarrow \vec{X}$ be the functions defined by $\delta_i(\vec{x})=\delta(\vec{x})(i)$ for $i \in 2$ (i.e., $\delta_0$ is a partial application of $\delta$ given $0$ and $\delta_1$ is a partial application of $\delta$ given 1); %, since $(1,1)$ replaces $(0,0)$ due to the fault. 
the trace of the sequence $00$ is 
\begin{align*}
   [(0,0),(0,0)]&\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{\delta_0\times\delta_0}[(0,0),(0,1)]\\
   &\xrightarrow{\id\times m}[(0,0),(1,0)]\xrightarrow{\delta_0\times\delta_0}[(0,0),(0,1)]\\
   &\xrightarrow{\id\times m}[(0,0),(1,0)]\xrightarrow{F\times F}[0,0],
\end{align*}
so $00$ is rejected by both automata. 
%Note that $\delta_0(1,1)=(0,1)$, but since $(1,0)$ replaces all read uses of $(0,1)$, we apply the fault directly. 
Now, if we receive the sequence $10$, the resulting state trace is 
\begin{align*}
    [(0,0),(0,0)]&\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{\delta_1\times\delta_1}[(1,0),(1,1)]\\
   &\xrightarrow{\id\times m}[(1,0),(0,0)]\xrightarrow{\delta_0\times\delta_0}[(0,1),(0,0)]\\
   &\xrightarrow{\id\times m}[(1,0),(1,1)]\xrightarrow{F\times F}[0,1];
\end{align*}
the transformed automaton accepts $10$, but the original automaton does not. 
The trace of the sequence $11$ is 
\begin{align*}
    [(0,0),(0,0)]&\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{\delta_1\times\delta_1}[(1,0),(1,1)]\\
   &\xrightarrow{\id\times m}[(1,0),(0,0)]\xrightarrow{\delta_1\times\delta_1}[(1,1),(1,0)]\\
   &\xrightarrow{\id\times m}[(1,1),(0,1)]\xrightarrow{F\times F}[1,0],
\end{align*}
so $11$ is accepted by the original automaton, but rejected by the transformed automaton. 
For the sequence $110$, the resulting state trace is 
\begin{align*}
    [(0,0),(0,0)]&\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{\delta_1\times\delta_1}[(1,0),(1,1)]\\
   &\xrightarrow{\id\times m}[(1,0),(0,0)]\xrightarrow{\delta_1\times\delta_1}[(1,1),(1,0)]\\
   &\xrightarrow{\id\times m}[(1,0),(0,1)]\xrightarrow{\delta_0\times\delta_0}[(0,1),(0,0)]\\
   &\xrightarrow{\id\times m}[(0,1),(1,1)]\xrightarrow{F\times F}[0,1];
\end{align*}
the transformed automaton accepts $110$, but the original automaton does not. Finally, the original automaton rejects the empty sequence $\varepsilon$, but the transformed automaton accepts it, since 
\begin{align*}
    [(0,0),(0,0)]\xrightarrow{\id\times m}[(0,0),(1,1)]\xrightarrow{F\times F}[0,1].
\end{align*} 

% The map $m$ pairs each state with its corresponding transformed representation. %If there were no faults, the map $m$ would be the identity map. 
% The fault forces the state $(0,0)$ to behave like its image under $m$, i.e., the behaviour of $(0,0)$ in the transformed system should behave like $(1,1)$. Similarly, the state $(1,1)$ should behave $(0,0)$. 
%(We can alternatively see the function $m$ as a bad abstraction from the implementation.)

%There are now two final states: $(1,1)$ and $(0,1)$ since both states are preimages of $(1,1)$ under $m$.
We obtain the automaton shown in Figure~\ref{fig:Transformed} by ``copying'' the original behaviour from images of $m$ to their preimages. Figure~\ref{fig:ExampleWithFaults} shows this procedure for $(0,0)$ and $(1,1)$. This includes copying the behaviour under $\delta$ and under $F$. 

We preserve the initial state because $\vec{x}_0$ is a selection/construction/algebraic operation, not a dynamics/behavioural/coalgebraic operation. We do not apply transformations to the results of algebraic operations to avoid aggregating the transformation erroneously due to composition of algebraic and coalgebraic operations. Consider the following: the initial state $\vec{x}_0$ is of type $1\rightarrow\vec{X}$ which is algebraic, so the only way to apply $m$ to $\vec{x}_0$ is by composing it on the left, i.e., $m\circ \vec{x}_0(0)$. Checking if the initial state is accepting in the original automaton corresponds to the expression $(F\circ\vec{x}_0)(*)$; however, the expression
\begin{align*}
    (F\circ m)\circ (m\circ\vec{x}_0)(0)= (F\circ m)(1,1)=F(0,0)=0,
\end{align*}
applies $m$ twice, and it fails to properly check if the initial state of the transformed automaton is final. Instead, the correct expression is 
\begin{align*}
    (F\circ m)(\vec{x}_0)= (F\circ m)(0,0)=F(1,1)=1.
\end{align*}
% In other words, since $m(0,0)=(1,1)$, we copy the original behaviour of $(1,1)$ and we give it to $(0,0)$, including that $(1,1)$ is an accepting state; similarly, since $m(1,1)=(0,0)$ we copy the original behaviour of $(0,0)$ to $(1,1)$. 
% We do not change the initial state because 

\begin{figure}[t]
    \centering
    \begin{tikzpicture}
        \node[state] (00) {$(0,0)$};
        \node[state, below right of=00] (01) {$(0,1)$};
        \node[state, above right  of=00] (10) {$(1,0)$};
        \node[state, below right of=10] (11) {$(1,1)$};
        \draw 
        (00) edge[above, bend left, dashed,color=gray] node[color=lightgray]{1} (10)
        (00) edge[loop above, dashed,color=gray] node[color=lightgray]{0} (00)
        % (01) edge[bend left, dashed,color=gray] (10)
        % (01) edge[bend left, below, dotted, color=gray](00)
        % (10) edge[bend left, dashed, color=gray] (11)
        % (10) edge[bend left, right, dotted, color=gray] (01)
        (11) edge[loop above, dashed, color=gray] node[color=lightgray]{1} (11)
        (11) edge[bend left, below, dashed, color=gray]node[color=lightgray]{0} (01)
        %Mutation Arrows
        (00) edge[color=gray, dotted] (11) 
        % (01) edge[color=red,dotted]  (10)
        % (10) edge[color=red, dotted]  (01)
        (11) edge[color=gray, dotted] (00)
        %New arrows
        (00) edge[bend right, below,color=red] node{0} (01)
        (00) edge[bend right, below,color=red] node{1} (11)
        (11) edge[bend right, above,color=red] node{0} (00)
        (11) edge[bend right, above,color=red] node{1} (10)
        % (11) edge[above] node{1} (1,0)
        % (11) edge[bend right, above] node[near start]{0} (00)
        ;\end{tikzpicture}
    \caption{Composition of the fault $m$ and the original behaviour for the states $(0,0)$ and $(1,1)$. The dotted, gray, bidirectional arrow in the centre models the effect of the fault $m$. The original behaviours appear as dashed, grey lines. The behaviour which results from the composition appears as solid, red lines.}
    \label{fig:ExampleWithFaults}
\end{figure}
We say that the transformed system is \emph{latent} with respect to the original system, since the application of the transformation $m$ reveals the new behaviour. In general, we cannot reveal arbitrary behaviours only through transformations of the state space; e.g., we cannot obtain an automaton that accepts every sequence from a single-state automaton that rejects all sequences by just transforming the state space. 

In the following, we present a general treatment for spatial transformations and latent behaviours in the context of $F$-coalgebras. We describe the limitations on revealing new behaviours through  spatial transformations in arbitrary $F$-coalgebras, and we also describe the necessary conditions that lift these limitations.

% To transform an automaton which accepts all sequences into one that can reject some or all, we need a transformation of the \emph{functionality}. 
% Those transformations correspond to the arrow $F(X)\xrightarrow{b}F(X)$ in Figure~\ref{fig:TheArrow}. 
% \todo[inline]{the final coalgebra is the place where spatial, dynamics, and coalgebras meet. Spatial transformations abstract a behaviour acting concurrently with the one we are currently studying, and that's why they are interesting to study.}
%However, systems revealed by transformations of type $F(X)\xrightarrow{b}F(X)$ are not latent by definition. %In this thesis, we are interested in seeing how far we can go with just carrier transformations; i.e., with latent behaviours.
 
% \todo[inline]{Remark eventually that we cannot model every malicious behaviour of the programmer, only those that affect state, not functionality.}
\section{Latent $F$-coalgebras and Latent Behaviours}
Given an $F$-coalgebra $(X,c\colon X\rightarrow F(X))$, each state $x\in X$ has an associated dynamics function $c(x)\in F(X)$. In this section, we study the effect of a state transformation $m\colon X\rightarrow X$ over the $F$-coalgebra $(X,c)$, which changes the dynamics of $x\in X$ from $c(x)$ to $c\circ m(x)$. 

In terms of types, we can always compose the function $c$ with any carrier transformation $m$; the composition $c \circ m\colon X\rightarrow F(X)$ exists and is well defined. However, the behaviour of elements might be greatly affected. In particular, states which are bisimilar under $c$ might no longer be bisimilar under $c \circ m$. If $m$ preserves bisimilarity, then we say that $m$ is \emph{behaviourally consistent}.

\begin{definition}[Behaviourally Consistent Spatial Transformations]
Given an $F$-coalgebra $(X,c)$, any function of type $m\colon X\rightarrow X$ is a \emph{spatial transformation}. %A transformation $m\colon X \rightarrow X$ has \emph{finite support} iff $m(x)\neq x$ only for a finite number of $x\in X$. We denote the set of finitely supported transformations by $X^X_\omega$. 
A spatial transformation $m$ is \emph{behaviourally consistent} if and only if, whenever $x\sim_c y$, then $m(x)\sim_{c} m(y)$, for all $x,y \in X$. %We denote the set of consistent transformations by $X^X|_\sim$. %
\end{definition}
%Henceforth, we consider only minimal systems, unless explicitly mentioned otherwise. 
\begin{corollary}
    If $(X,c)$ is a minimal $F$-coalgebra, then every spatial transformation %$m\colon X\rightarrow X$ 
    is behaviourally consistent. %  This property also holds if $(X,c)$ is a sound coalgebraic specification language.
\end{corollary}
Applying transformation function $m\colon X\rightarrow X$ in the context of an $F$-coalgebra $(X,c$) changes the normal behaviour of the states in $X$, and it reveals the \emph{latent coalgebra of $(X,c)$ under $m$}. 
\begin{definition}[Latent Coalgebra and Latent Behaviour]
Given an $F$-coalgebra $(X,c)$ and a transformation $m$, the \emph{latent coalgebra of $(X,c)$ under $m$} is $(X,c\circ m)$. 
\end{definition}
% \begin{align}
%     \mathbb{X}\circ m\triangleq(X,{(o\circ m, \delta\circ m })).
% \end{align}
% The function $\TheLatentBehaviourOfIn{\cdot}{m}{c}\colon X\rightarrow \sigma F$ defines the \emph{latent behaviour} under $m$. The homomorphism $\TheLatentBehaviourOfIn{\cdot}{m}{c}$ corresponds to the semantic map of the $F$-coalgebra $(X,c\circ m)$; that is, for $x\in X$, 
The semantic map $!_{c\circ m}$ %$\TheBehaviourOfIn{x}{{c\circ m}}$ 
of the latent coalgebra $(X,c\circ m)$ characterises the \emph{latent behaviours} revealed $m$. 

\begin{example}
\label{ex:Latent:TheExample}
Consider the automaton from Section~\ref{sec:Latent:Motivation} which recognises the language $(0|1)^*11$. Let $F$ be the functor $F(X)=2\times X^2$; we model the automaton with an $F$-coalgebra $(\vec{X},(F,\delta))$, where $\vec{X}=2\times2$ and $(F,\delta)\colon X\rightarrow 2\times X^2$ is a function pair, defined for $(x,y)\in \vec{X}$ by
\begin{align}
    F(x,y)&\triangleq x \land y\\
    \delta(x,y)(i)&\triangleq (i,x).
\end{align}
Just like its automaton counterpart, this $F$-coalgebra is not minimal, since $(0,0)$ and $(0,1)$ are bisimilar
There are $|X|^{|X|}=256$ different spatial transformations, but that does not imply the existence of 256 different latent coalgebras; e.g., the transformations $\Delta_{(0,0)}$ and $\Delta_{(0,1)}$ which respectively map all states to $(0,0)$ and $(0,1)$ yield isomorphic latent coalgebras, since $(0,0)$ and $(0,1)$ are bisimilar; both of these latent coalgebras recognise the empty language starting in all states. 
The transformation $m(x,y)=(\lnot x,\lnot y)$ reveals the latent coalgebra where 
\begin{align}
    (F\circ m)(x,y)&= \lnot x \land \lnot y\\
    (\delta\circ m)(x,y)(i)&= (i,\lnot x).
\end{align}
The behaviour of a state $x$ changes when $m$ acts on $x$. In particular, the image of state $(0,0)$ under the semantic map is no longer the language $(0|1)^*11$; it is the language $\varepsilon|(0|1)^*10$ instead.
\end{example}
% \todo[inline]{There is no notion of distance or how different behaviours are in this setting. Things either are equal/isomorphic or they are not.}
\section{Latent Behaviour Analysis}
LBA is the study of the effects that a spatial transformation $m\colon X\rightarrow X$ has over the behaviour of states in $X$ in the context of an $F$-coalgebra $(X,X\xrightarrow{c} F(X))$. The choice to focus on spatial transformations seems arbitrary; clearly, it is also possible to affect the behaviour of states by composing $c$ with a {dynamics transformation} $b\colon F(X)\rightarrow F(X)$ to obtain the new dynamics function $b \circ c$, as shown in the "Arrow" from Figure~\ref{fig:TheArrow}. %Both $(X,b\circ c\colon X\rightarrow F(X))$ and $(X,b\circ c\circ m\colon X\rightarrow F(X))$ are $F$-coalgebras, since the type requirement is satisfied. 
However, there are systems for which spatial and behavioural transformations can reveal the same behaviours; moreover, we can reveal any arbitrary behaviours via spatial transformations: \emph{final $F$-coalgebras}, and \emph{sound and complete coalgebraic specification languages}.

%\subsection{Latent Coalgebras of Final $F$-coalgebras}
A final $F$-coalgebra $(\sigma F, 1_F)$ has a dynamics function $1_F\colon \sigma F \rightarrow F(\sigma F)$ that is an isomorphism. Since $\sigma F \simeq F(\sigma F)$, it naturally follows that 
\begin{align}
    \sigma F\rightarrow \sigma F \simeq \sigma F\rightarrow F(\sigma F) \simeq F(\sigma F)\rightarrow F(\sigma F).    
\end{align}
In other words, in the carrier of the final $F$-coalgebra, spatial transformations (of type $\sigma F\rightarrow \sigma F$), dynamics transformations (of type $F(\sigma F)\rightarrow F(\sigma F)$) and $F$-coalgebras (of type $\sigma F\rightarrow F(\sigma F)$) are in a one-to-one correspondence. 

Intuition tells us that $1_F\colon \sigma F \rightarrow F(\sigma F)$ should correspond to $\id_{\sigma F}\colon \sigma F\rightarrow \sigma F$ and should correspond to $\id_{F(\sigma F)}\colon F(\sigma F)\rightarrow F(\sigma F)$. The general correspondence is given by the following proposition.
\begin{proposition}
    For every $F$-coalgebra $(\sigma F, c)$, there are transformations $m\colon \sigma F\rightarrow \sigma F$ and $b\colon F(\sigma F)\rightarrow F(\sigma F)$ such that the diagram in Figure~\ref{fig:FinalEquivalence} commutes.
\end{proposition}
\begin{proof}
    Since $1_F\colon \sigma F\rightarrow F(\sigma F)$ is an isomorphism, by taking $m=1_F^{-1}\circ c$ and $b=c\circ 1_F^{-1}$, the diagram in Figure~\ref{fig:FinalEquivalence} commutes.
\end{proof}
\begin{corollary}
    Every $F$-coalgebra $(\sigma F, c)$ is a latent coalgebra of $(\sigma F, 1_F)$ under some spatial transformation $m\colon \sigma F\rightarrow \sigma F$.
\end{corollary}

\begin{figure}[t] 
    \centering
    \begin{tikzcd}[column sep=1.5cm, row sep=1.5cm]
         \sigma F
            \arrow[r,"m"]
            \arrow[dr,"c"]
            \arrow[d,"1_F"']
        &\sigma F
            \arrow[d,"1_F"]
        \\
         F(\sigma F)
            \arrow[r,"b"']
        &F(\sigma F)
            %\arrow[u,"1^{-1}"']
    \end{tikzcd}
    \caption{Every $F$-coalgebra $(\sigma F, c)$ can be revealed from the final coalgebra $(\sigma F,1_F)$ by means of a transformation $m$ or a transformation $b$. In other words, it suffices to use spatial transformations $m$ and the final $F$-coalgebra to reveal all $F$-coalgebras of $\sigma F$, so dynamics transformations $b$ are unnecessary.}
    \label{fig:FinalEquivalence} 
\end{figure}
This property applies to the carrier of the final coalgebra because of the reversibility of the final dynamics map $1_F$, which formalises a correspondence between state and behaviour. This property is also shared by sound and complete coalgebraic specification languages, since their semantic map is an epimorphism. For an arbitrary $F$-coalgebra $(X,c)$, only some latent $F$-coalgebras can be revealed by spatial transformations $m\colon X\rightarrow X$. It would not be an exaggeration to state that $F$-coalgebras which satisfy this property have all the "necessary gadgets" (with respect to the functor $F$) to reveal any arbitrary functionality using spatial transformations. 

%\subsection{$F$-Coalgebras as Endofunctions}
Given a final $F$-coalgebra $(\sigma F, 1_F)$ and an arbitrary coalgebra $(\sigma F, c)$, the spatial transformation $\omega\colon \sigma F\rightarrow \sigma F$, defined by $\omega\triangleq 1_F^{-1}\circ c$, implements $c$. The identity spatial transformation implements $1_F$. This duality between $F$-coalgebras and spatial transformations in $\sigma F$ enables a natural composition of $F$-coalgebras in $\sigma F$.
%This treatment simplifies the composition of $F$-coalgebras in $\sigma F$. 

%When we compose $F$-coalgebras we are applying their behaviour functions sequentially. 
Given two $F$-coalgebras $(\sigma F, c_1)$ and $(\sigma F, c_2)$ whose respective spatial transformation implementations are $\omega_1$ and $\omega_2$, the composition $\omega_2\circ \omega_1$ gives rise to the following equivalent concepts:
\begin{itemize}
    \item the $F$-coalgebra $(\sigma F, c_2\circ 1_F^{-1}\circ\omega_1)$,
    \item the latent coalgebra of $(\sigma F, c_2)$ under $\omega_1$,
    \item the latent coalgebra of $(\sigma F, 1_F)$ under $\omega_2\circ \omega_1$.
\end{itemize}
In summary, we can represent $F$-coalgebras whose carrier is $\sigma F$ by endofunctions in $\sigma F$, and we can reason about their composition as we would with functions in the monoid of endofunctions $(\sigma F\rightarrow \sigma F, \circ, \id)$. 

% \todo[inline]{Explain that this corresponds to the point of The Arrow: $!c$ takes you from $X$ to $\sigma F$, and you can use $\omega$ to reveal a latent coalgebra of $(\sigma F, 1)$. This arrow $\omega$ models the behavioural change from $!c$ to $!_{b\circ c\circ m}$.}
In the following, we return to arbitrary $F$-coalgebras $(X,c)$, but we keep in mind the following: when we reveal a latent coalgebra of $(X,c)$ under a spatial transformation $m$, we are implicitly sequentially composing the behaviour function $c$ with the behaviour function of the $F$-coalgebra implemented by $m$; first we apply $m$ and then we apply $c$.

\section{Some Applications of Latent Behaviour Analysis}
% \todo[inline]{Describe in terms of coalgebras an introduction for the three application topics we have: attacker model classification, CPS redesign and Side-channel repair.}
We study the effects that spatial transformations have on the behaviour of the system. Just like in geometry, some spatial transformations may preserve some properties of the system, while others may break them. In this section, we present three ideas for LBA to study four aspects of systems: \emph{formalisation of integrity attackers}, \emph{quantifying and improving robustness}, \emph{classification of attacker models}, and \emph{side-channel repair}.

% Consider the system from Section~\ref{sec:Latent:Motivation} and it coalgebraic equivalent presented in Example~\ref{ex:Latent:TheExample}. This example has 256 different spatial transformations, which affect the system in different ways. 
% \todo[inline]{I dunno where I was going with this}

% {\color{blue} Working with endofunctions is nice because you can study e.g. those with finite support. Endofunctions with finite support finitely compose nicely, and you can use them to model incremental changes to behaviour.

% What I need to do though is to hint towards potential applications. This section describes that in final coalgebras it suffices to compose endofunctions to model behaviours. In arbitrary coalgebras however, we can 
% }
% Composition of $F$-coalgebras is non-commutative. 
% \begin{theorem}[Fundamental Theorem of Latent Behaviour Analysis]
%     \label{theo:Fundamental}
%     The semantic map-ping of the $F$-coalgebra $(X,c\circ m\colon X\rightarrow F(X))$ factors through the semantic map of the $F$-coalgebra $(m(X),c\colon m(X)\rightarrow F(m(X)))$
%     \todo[inline]{This probably needs to use bounded functors.}
% \end{theorem}
%This composition is in general not commutative.

% Consider an example in automata: we define $m\colon \sigma F\rightarrow \sigma F$ such that 
% \begin{align*}
%     m(\phi)(w)=
% \begin{cases}
%     \phi(w), \quad \text{if $w$ ends in 1},\\
%     0,\quad \text{otherwise}.
%     % \lnot \phi(w), \quad \text{if $w\varepsilon$}\\
%     % \phi(w), \quad \text{otherwise}.
% \end{cases}
% \end{align*}
% In other words, $m$ removes all sequences that do not end in $1$ from the language characterised by $\phi$. We obtain $c=1\circ m$

% In the case of automata, what does it mean for $c(L)=L'$ Normally what we have is $L\mapsto (0|1, 0\mapsto L_0, 1\mapsto L_1)$. 

% \todo[inline]{Something is not right: In the case of automata, }


% , and such a set of revealed behaviours is determined by the available \emph{gadgets}.

% \section{Gadgets}
% In the context of return-oriented programming~(\cite{ROP}), a \emph{gadget} is a code snipped that is part of the original program, and it is exploited by attackers to hijack the control flow once they affect the return addresses of functions. In the context of LBA, given an $F$-coalgebra $(X,c)$, if $c$ defines the program, then the components of $c$ define the set of \emph{gadgets} we can use to change the behaviour of the system.
% \begin{definition}[Gadgets]
%     Let $\mathbb{X}=(X,c)$ be an $F$-coalgebra. 
%     A \emph{gadget of $\mathbb{X}$} is a pair $(x,c)$ where $x\in X$. %The set of \emph{gadgets of $\mathbb{X}$} by the graph of $c$. 
% \end{definition}

% A gadget $(x,c)$ is a behavioural building block. We can interpret the gadget $(x,c)$ as the action of applying $c$ at $x$, so $(m(x),c)$ models the action of applying $c$ to $m(x)$. 

% In the example presented in Section~\ref{sec:Latent:Motivation}, there are four gadgets. Each gadget gives each spatial transformation $m$ a chance to further alter the behaviour of the system. 
% \todo[inline]{Where do you want to go with this? It looks interesting, but not useful. }

% In the following, we work on arbitrary $F$-coalgebras $(X,c)$ and only consider spatial transformations to

% \todo[inline]{If we want $a$ to change with time there is no need to do anything fancy! We can enhance the carrier by doing $X'=X\times \mathbb{N}$ or $X'=X\times [X\rightarrow 2]$; with this, $X$ is enhanced by a natural number counter or a set of conditions to make the dynamics of the transformation coalgebra more interesting. Maybe there is even no need to do changes, it all depends on how informative $X$ is. let's see}

% \todo[inline]{This means that the problem becomes a "searching for the next candidate at every step" problem. Alternatively, you could learn to compose solutions too. }
% \todo[inline]{Maybe we can also do something exciting: eventuality -> at some point in time, the behaviour you want becomes apparent, i.e. $\TheBehaviourOf{x_0}^w=\rho$ for some $w$}

\subsection{Formalisation of Integrity Attacks and Attacker Models}
\label{sec:Latent:AttackerModels}
Consider the following definition of \emph{arbitrary state-based attacks}.
\begin{definition}[Arbitrary State-based Attack]
    \label{def:Latent:StateAttacks}
    Given an $F$-coalgebra $(X,c)$, the set of its \emph{state-based attacks} is the set of its spatial transformations, i.e., $X^X$. 
    %We also define the set of its \emph{behaviour-based attacks} by $F(X)^{F(X)}$. 
    \end{definition}
Under this definition, LBA studies the effect of state-based attacks. Henceforth, when we refer to an attack, we implicitly mean a state-based attack (unless stated otherwise). In the particular case of final $F$-coalgebras, their state-based attacks coincide with their behaviour-based attacks. 
\todo[inline]{Fix this and make the sections smaller and more coherent}

\subsection{Classification of Attackers}
\label{sec:Latent:Classification}
In Chapters~\ref{ch:Classification} and ~\ref{ch:CPSRobustness}, we compare and classify attackers based on their model. The intuition is the following: given an $F$-coalgebra $(\vec{X},c)$ where $\vec{X}$ is a product type of finite types whose coordinates are $\Pi=\set{\pi_1,\ldots,\pi_p}$, and a list of requirements $\mathcal{R}=\set{R_1, \ldots, R_n}$, we can systematically generate attacker models by choosing a subset of coordinates in $\Pi$. Under this formulation, the set of attacker models is characterised by $\ThePowersetOf{\Pi}$. Since attacker models are characterised by sets, we can compare them via set inclusion. This comparison sorts attackers by \emph{capabilities}; i.e., it classifies attackers with respect to the ways they can interact with the system. Then, using LBA, we obtain the set of requirements $\AsSequence{\alpha}[\mathcal{R}]$ broken by attackers fitting the model $\AsSequence{\alpha}$, and we compare these sets of requirements by set inclusion to compare attacker models by their \emph{power}; i.e., for two attacker models $\AsSequence{\alpha}$ and $\AsSequence{\beta}$, if $\AsSequence{\alpha}[\mathcal{R}]\subset \AsSequence{\beta}[\mathcal{R}]$, then $\AsSequence{\beta}$ breaks strictly more requirements than $\AsSequence{\alpha}$, making attackers which fit the model $\AsSequence{\beta}$ more dangerous adversaries than those which fit the model $\AsSequence{\alpha}$.%The attacker model corresponding to $\emptyset$ is the passive attacker, and the attacker 

{\color{red}
\subsection{Quantifying and Improving Robustness}
\label{sec:Latent:Robustness}
Informally, the robustness of a system quantifies how much stress the system can withstand without compromising its functionality. We explore the idea of modelling stress via state-based attacks and how we can quantify and improve the robustness of a system by studying properties of latent coalgebras.

Formally, we are given a set of behavioural properties $\mathcal{R}=\set{R_1, \ldots, R_n}$ which model both functional and security requirements of a system described by an $F$-coalgebra $(X,c)$ with an initial state $x_0\in X$, %and a set of behavioural properties $\mathcal{R}=\set{R_1, \ldots, R_n}$ and
we are also given a spatial transformation $m\colon X\rightarrow X$ that models an attack or a fault;  %Normally, we would check if $x_0$ satisfies all behavioural properties in $\mathcal{R}$, but now 
we say that the system is robust with respect to $m$ if $x_0$ still satisfies all the given behavioural properties despite the effects of the spatial transformation $m$.

To check for robustness with respect to $m$, we might think that it suffices to check $(R_i\circ !_c)(m(x_0))=1$ for each requirement $R_i$, but that is incorrect: the expression $(R_i\circ !_c)(m(x_0))=1$ only checks if the effect of $m$ on the initial state is enough for $R_i$ to fail, and it ignores the effect of $m$ on the rest of the states. The correct way is to reveal the latent coalgebra $(X, c\circ m)$ and check if it satisfies the behavioural properties $\mathcal{R}=\set{R_1, \ldots, R_n}$ using standard model checking/testing techniques. 

% as illustrated by the following example.
% \begin{example}[Faulty Verification]
%     In the context of Example~\ref{ex:Latent:TheExample}, the functor is $F(X)=2\times X^2$, and it has a final $F$-coalgebra $(2^{2^*},(\varepsilon?,(\cdot)'))$ where $\varepsilon? \colon 2^{2^*}\rightarrow 2$ checks whether the empty sequence $\varepsilon$ belongs to the language and $(\cdot)'\colon 2^{2^*}\rightarrow (2\rightarrow {2^{2^*}})$ computes the Brzozowski derivative~\cite{BrzozowskiDerivative} of the language.  
%     %\todo[inline]{Maybe move to preliminaries?}

%     Let $R\colon 2^{2^*}\rightarrow 2$ be the behavioural property defined by $R(\phi)\triangleq \phi \sim \varepsilon|(0|1)^*10$, for $\phi \in 2^{2^*}$. The property $R$ is not satisfied by any state of the original $F$-coalgebra, so $(R\circ !_c)(m(x_0))$ would be 0 for all spatial transformations $m$; nevertheless, $R$ is satisfied by $x_0$ in the latent coalgebra revealed by the spatial transformation $m(x,y)=(\lnot x, \lnot y)$ used in Example~\ref{ex:Latent:TheExample}, since it is the language the state $(0,0)$ recognises in the latent coalgebra. 
% \end{example}
%Part of the novelty of LBA is that we can study a latent coalgebra $(X, c\circ m)$ just as we would study the original coalgebra $(X, c)$. By this, we mean that we can apply testing and verification techniques without complication. 
% In the following, we illustrate how we can use spatial transformations to model attacks which target the state of systems rather than the program, and we study the details of this approach in Chapter~\ref{ch:CPSRobustness} when we apply it to cyber-physical systems.


We know that an attack $m$ reveals a latent coalgebra $(X, c\circ m)$ which may or may not satisfy the same behavioural properties that $(X, c)$ satisfies. We could check whether $(X,c\circ m)$ satisfies all requirements in $\mathcal{R}$, but this is not very informative if we arbitrarily choose $m$. We propose to systematically generate a set of spatial transformations $\mathcal{M}=\set{m_1,\ldots, m_p}$ based on some attacker model, and test whether each revealed latent coalgebra $(X, c\circ m_i)$ satisfies each requirement $R_j$ for $m_i\in \mathcal{M}$ and $R_j\in \mathcal{R}$. If a requirement $R$ is not satisfied in some latent coalgebra $(X, c\circ m)$, then the attacker can use $m$ to break $R$ in the original system $(X,c)$; in this case, we say that \emph{the attack $m$ breaks the requirement $R$}. If no attack in $\mathcal{M}$ breaks any requirement in $\mathcal{R}$, then we say that the system is \emph{robust} against the attacker model that generated $\mathcal{M}$. This approach gives us a qualitative notion of robustness.

We can extend qualitative robustness into quantitative robustness by discounting broken requirements. More precisely, given $(X,c)$, $\mathcal{M}$, and $\mathcal{R}$ such that $|\mathcal{R}|=n$, we can define the set $\mathcal{M}[\mathcal{R}]$ of requirements in $\mathcal{R}$ that are broken by one or more attacks in $\mathcal{M}$; similarly $m[\mathcal{R}]$ is the set of requirements that $m$ breaks. We estimate the robustness of the system by the formula 
\begin{align*}
    \sum_{i=i}^n{w_i(1-(R_i\in \mathcal{M}[\mathcal{R}]))},
\end{align*}
where $w_i\in \mathbb{R}^+$ is a weight which models the importance of requirement $R_i$.

Let us consider the case where $(X,c)$ fails a non-empty set of requirements; this set, given the definitions, is equal to $\id[\mathcal{R}]$. Now, let $\mathcal{K}=\set{k_1, \ldots, k_q}$ be an arbitrary set of spatial transformations independent of $\mathcal{M}$; we say that a spatial transformation $k\in \mathcal{K}$ \emph{repairs $(X,c)$} if $k[\mathcal{R}]\subset \id[\mathcal{R}]$; we say that $k$ \emph{fully repairs $(X,c)$} if $k[\mathcal{R}]$ is empty. The set spatial transformations $\mathcal{K}$ corresponds to a repair toolkit, which we generate systematically just like we did with the set of attacks $\mathcal{M}$. We study the process of system repair in more detail in Chapter~\ref{ch:SideChannelRepair}.

We now consider an analysis that combines both $\mathcal{M}$ and $\mathcal{K}$ as follows: if an attack $m\in \mathcal{M}$ breaks some requirements, is there a \emph{counterattack} $k$ that fully repairs $(X,c\circ m)$? If so, we can improve the robustness of the system $(X,c)$ by transforming it into $(X,c\circ m \circ k)$ whenever we detect that the attack $m$ is affecting $(X,c)$; we refer to this dependent notion of robustness as \emph{latent robustness}, and we explore this concept in cyber-physical systems during Chapter~\ref{ch:CPSRobustness}.
\begin{example}[An attack is its own counterattack]
    In the context of Example~\ref{ex:Latent:TheExample}, consider the behavioural property $Q\colon 2^{2^*}\rightarrow 2$ which accepts a language $\phi \in 2^{2^*}$ if and only if $\phi$ accepts a sequence $w\in 2^*$, then $w$ ends in 1 or $w$ is empty.

    In the original $F$-coalgebra, all states in $2\times 2$ satisfy the property $Q$ since both $(0,0)$ and $(1,0)$ recognise the language $(0|1)^*11$, $(0,1)$ recognises the language $(0|1)^*1$, and $(1,1)$ recognises $\varepsilon + 0(0|1)^*11 + 1(0|1)^*1$. However, in the latent coalgebra revealed by the attack $m$, which maps $(a,b)$ to $(\lnot a, \lnot b)$, the state $(0,0)$ no longer satisfies $Q$, since it now recognises the language $\varepsilon|(0|1)^*10$. 

    Now, if we use $m$ again in the latent coalgebra $(2\times 2, c\circ m)$ to reveal the latent coalgebra $(2\times 2, c\circ m\circ m)$, we repair the system with respect to the property $Q$, since $m \circ m=\id$. Thus, $m$ can be used as its own counterattack, but only when the latent coalgebra $(2\times 2, c\circ m)$ has been revealed (otherwise, the application of $m$ reveals $(2\times 2, c\circ m)$, and it breaks $Q$).
\end{example}

% Given an attacker model which generates the set of attacks $\mathcal{M}$, 

% Considering that latent coalgebras are coalgebras, we could apply LBA to latent coalgebras. 

% There are two dimensions we can explore: one, given $(X, c)$ and $m$, we can iterate over $\mathcal{R}$ and check whether $(X,c)$ and $(X,c\circ m)$ satisfy $R$ for $R\in \mathcal{R}$, or two, given $(X,c)$ and $\mathcal{R}$
% % Different $F$-coalgebras have different sets of attacks. In our framework, a minimal $F$-coalgebra $(X,c)$ has as many attacks as $|X|^{|X|}$.
}


\subsection{Side-Channel Repair}
The last application of LBA that we consider is of program repair. We briefly mentioned the idea in Section~\ref{sec:Latent:Robustness}: given an $F$-coalgebra $(X,c)$ and a set of requirements $\mathcal{R}=\set{R_1, \ldots, R_n}$, if $\AsSequence{\emptyset}[\mathcal{R}]$ is non-empty (i.e. the system fails some requirements), then we can look for spatial transformations to reveal a latent behaviour $(X,c\circ m)$ such that $\set{m}[\mathcal{R}]$ is empty. We consider an interesting case where the state $x$ is a program, and $R$ consists of a single requirement: constant memory access patterns. We propose an idempotent spatial transformation $\mathcal{O}$ which maps $x$ to a state which satisfies constant memory access patterns. In Chapter~\ref{ch:SideChannelRepair}, we show how we can use $\mathcal{O}$ to repair a family of timing side-channel leaks for LLVM programs.





