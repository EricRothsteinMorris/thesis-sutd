%!TEX root = ../main.tex
\chapter{Conclusion}
Thorough this thesis, we used the Research Questions~\ref{que:AttackerModel},~\ref{que:Quantification},~\ref{que:Classification} and~\ref{que:Repair} to provide an intuition of the usefulness of LBA. We studied these questions in three practical scenarios: the classification of attacker models in Chapter~\ref{ch:Classification}, the quantification of robustness in CPS in Chapter~\ref{ch:CPSRobustness}, and timing side-channel repair in Chapter~\ref{ch:SideChannelRepair}. Although these three applications are quite different in terms of the domain of their problems, we successfully approached them using LBA, attesting the applicability and generality of the method. 

With respect to Research Question~\ref{que:AttackerModel} -- the modelling of attacks and attacker models-- we conclude that LBA is expressive enough to model practical attackers, including man-in-the-middle attackers and attackers that can override the values of state variables while leaving the program of the transition system intact. Nevertheless, due to its focus on spatial transformations, LBA has limitations in its applicability. For example, we cannot capture the attackers of a transition system that can directly change the transition relation. To model this type of attackers, we would need to consider \emph{dynamics transformations}, the dual of spatial transformations, which we briefly discussed in Section~\ref{sec:Latent:Introduction}. LBA also cannot capture attackers that can add or remove states from the carrier set. However, there may be sets of spatial transformations in the resulting carrier set that emulate these attackers. 

To address Research Questions~\ref{que:Quantification} and~\ref{que:Classification} --the quantification of harmful effects of attackers and how to compare them-- we conclude that LBA can provide an adequate measure for these harmful effects, which we use to compare attackers. To compute this measure, we need a list of security requirements to determine when an effect is considered harmful, and a set of capabilities for each attacker model. LBA describes a framework to systematically generate systems that we can check using either verification or testing techniques. We used a verification approach in Chapter~\ref{ch:Classification} and a testing approach in Chapter~\ref{ch:CPSRobustness}. 

In a verification approach, we can use a SAT solver to find a spatial transformation that is capable of breaking at least one requirement. This method has the advantage that we need not need verify each spatial transformation generated by the attacker model, and a negative answer confirms the inability of the attacker to affect the system in a harmful way. However, this method is at a disadvantage if we are studying several attackers, since requires a heavy setup: to take advantage of the optimisations available in SAT solvers, we should avoid changing the model for each instance of model checking. This requirement implies that we should create a single model that contains all attackers, where we adjust the set of assumptions accordingly to define the attacker model we want to study. 

In a testing approach, we systematically generate spatial transformations corresponding to the attacker model, and we monitor the execution of the system after it has been affected by the spatial transformation. If a requirement is broken during the testing of a spatial transformation, then we conclude that the attacker can harm the system. The advantage of testing is that we obtain results relatively fast if either the attacker model generates a small amount of spatial transformations, or the system is particularly vulnerable to the attacker. The main disadvantage of a testing approach is that if the attacker model generates a large number of spatial transformations, it may be impractical to test them all, which can lead to inconclusive results.

Given these observations, we believe that the verification and testing approaches are complementary. We can do testing for the smaller attacker models, and verification for the larger attacker models. Smaller attacker models generate a treatable number of spatial transformations, which can be systematically tested. Moreover, thanks to monotonicity properties (see Theorem~\ref{theo:monotonicity} and Corollaries~\ref{cor:monodown} and~\ref{cor:monoup}), finding successful attackers that have minimal capabilities should be a priority. %Larger attacker models benefit from having a SAT or SMT solver decide which actions they should perform to be successful, 

Finally, with respect to the Research Question~\ref{que:Repair} --how to repair a system vulnerable to a given attacker model-- we propose two approaches: an approach based on finding counterattacks, shown in Chapter~\ref{ch:CPSRobustness}, and an enforcement mechanism via spatial transformations, shown in Chapter~\ref{ch:SideChannelRepair}. In Chapter~\ref{ch:CPSRobustness}, we quantify the robustness of a system with respect to the attacker model to obtain a relative measure of security. In addition, we consider a counterattacker model, and we use LBA to identify the attacks that have at least one counterattack. Based on the similarities between the attacks countered by a single counterattack, we can propose a repair (i.e. a change to the program of the system). To check if the repair is sound, we quantify the robustness of the new version to verify that it is greater than the robustness of the original system. In Chapter~\ref{ch:SideChannelRepair}, we use a spatial transformation to enforce a security property (i.e. timing side-channel freedom with respect to memory access patterns). This illustrates the dual purpose of spatial transformations: attackers can use them to break security requirements, and designers can use them to enforce security properties. 

To conclude this thesis, we briefly describe four directions for future work that, in our opinion, expand the theory and applicability of LBA.

% \section{Summary of Contributions}
% How do we precisely and systematically describe and generate attacker models, attacks and attackers?

% \todo[inline]{complete}

% In this thesis, 

%     We approach this question by modelling attacker models with sets of capabilities that create spatial transformations that model the attacks available for attackers fitting that model. We discuss this question in detail in Chapters~\ref{ch:LatentBehaviours},~\ref{ch:Classification}, and~\ref{ch:CPSRobustness}.
%     \begin{question}
%     \label{que:Quantification}
%     How do we efficiently quantify the effects of a set of attacker models attacker fitting a given attacker model on a system? 
%     \end{question}
%     The presence of an attacker does not necessarily imply a security risk, e.g., if the attacker can only slightly deviate the behaviour of the system without breaking any security requirements. To address this question, we propose a quantification method that uses bounded model checking in Chapter~\ref{ch:Classification} and that uses testing in Chapter~\ref{ch:CPSRobustness}. We implement the systematic quantification of the effect of attackers via LBA. 
     
%     \begin{question}
%     \label{que:Classification}
%     How do we compare attacker models and attackers concerning the impact that they potentially have on a given system?
%     \end{question}
%     Attackers that have more interaction points with a system are not necessarily the most dangerous. We take inspiration from Basin and Cremers~\cite{KnowYourEnemy} to approach this question. To determine which attackers are more threatening, we use the quantification methods proposed in Chapter~\ref{ch:Classification} and Chapter~\ref{ch:CPSRobustness} to obtain a partial order of attackers relative to their harmful effects on systems. In particular, thanks to our modelling of attackers via sets of spatial transformations, the partial order of attackers that naturally arises from set inclusion has a monotonicity property for the harmful effects of attackers on a system. We explain this monotonicity property in Chapters~\ref{ch:Classification} and~\ref{ch:CPSRobustness}.
    
%     \begin{question}
%     \label{que:Repair}
%     How do we repair a system that is vulnerable to a given attacker model?
%     \end{question}
% In this section, 

% Each of the chapters of the application module of the thesis, i.e., Chapters~\ref{ch:Classification},~\ref{ch:CPSRobustness} and~\ref{ch:SideChannelRepair}. In this chapter, we discuss and provide a conclusion of LBA as a paradigm for the study of systems, and we discuss possible avenues for future work.
%\section{Future Directions}

\section{Beyond Deterministic Transition Systems}
LBA is a framework rooted in universal coalgebra. 
Thus, LBA directly benefits from the major results in the theory of coalgebras. Most notably, LBA is extensible to systems tht incorporate monadic computation by means of the generalised determinisation procedure presented by Silva et al. in~\cite{GeneralisingDetermination}. 
Our intuition tells us that, given a monad $T$ with unit $\eta$ and multiplication $\mu$ that models a computational side-effect (e.g., non-determinism), and a functor $F$, the procedure in~\cite{GeneralisingDetermination} lifts an $FT$-coalgebra $(X,c)$ where $c\colon X\rightarrow F(T(X))$ to a semantically equivalent $F$-coalgebra $(T(X),c^\sharp)$ with $c^\sharp\colon T(X)\rightarrow F(T(X))$. We believe that a latent $FT$-coalgebra $(X,c\circ m)$ with $m\colon X\rightarrow X$ lifts to a semantically equivalent latent $F$-coalgebra $(T(X),c^\sharp\circ T(m))$, since $T(m)\colon T(X)\rightarrow T(X)$. 
%with $m^\flat\colon T(X)\rightarrow T(X)$, for some operator $\flat\colon X^X\rightarrow T(X)^{T(X)}$. The $\flat$ operator 
The functor $T$ aggregates the effects of $m$ in $X$ to obtain $T(m)$; e.g., in the case of non-determinism, if $X=\set{a,b}$ and $m\colon X\rightarrow X$ maps $a$ to $b$, and $b$ to itself, the transformation $\ThePowersetOf{m}\colon \ThePowersetOf{X}\rightarrow \ThePowersetOf{X}$ maps $\emptyset$ to itself, $\set{a}$ to $\set{b}$, $\set{b}$ to itself, and $\set{a,b}$ to $\set{b}$. We leave a definitive proof semantic equivalence between the latent $FT$-coalgebra $(X,c\circ m)$ and the latent $F$-coalgebra $(T(X),c^\sharp\circ T(m))$ as future work. %We do not yet know the properties of the $\flat$ operator that are required to ensure the existence of the lifted latent $F$-coalgebra, and we leave them for future work. 


\section{Predictability} 
By only using spatial transformations $m\colon X\rightarrow X$ and not dynamics transformations $b\colon F(X)\rightarrow F(X)$, we force every latent coalgebra $(X,c\circ m)$ to somehow factor through their original coalgebra $(X,c)$. While these latent coalgebras are clearly and undoubtedly related to their original coalgebra, the relations between the original behaviours and the revealed latent behaviours are, in general, hard to predict from the spatial transformations. We attribute this unpredictability to the lack of restrictions over the choice of spatial transformations. 

In geometry, we can predict the effect of some transformations on objects before we apply them, e.g., symmetries. We believe that there should be a non-trivial family of spatial transformations whose impact on the behaviour of systems is predictable before they are used (the trivial families of spatial transformations are constants and identity transformations). Our intuition points towards spatial transformations that naturally lift to dynamics transformation; more precisely, the transformations where the latent coalgebra $(X, F(m)\circ c)$ and $(X,c\circ m)$ have the same behaviours are predictable. The systems that satisfy this property are known as \emph{bialgebras} \cite{JacobsBook}. We leave formal proof of the predictability of the effects of spatial transformation in these systems as future work.

\section{A Proof Principle}
In this thesis, we studied the effects that a single spatial transformation $m\colon X\rightarrow X$ has on an $F$-coalgebra $(X,c)$; however, since $m$ is an element of the monoid of endofunctions in $X$, it can surely be non-uniquely decomposed into a finite sequence of transformations $m_1, m_2, \ldots m_n$ where $m=m_n\circ\ldots \circ m_2\circ m_1$ each with $m_i\colon X\rightarrow X$, where all $m_i$ preserve a behavioural property $Q$. If that is the case, then $(X,c\circ m)$ should satisfy the property $Q$. This proof principle follows the line of certified compilers (e.g., CompCert~\cite{CompCert}) that can transform one system into another while preserving their behavioural properties.

This proof principle seems particularly useful for a system $(X,d)$ that can be described as a latent coalgebra of a system $(X,c)$ and a spatial transformation $m$ (i.e., $d=c\circ m$), where $(X,c)$ is a system where proving the property $Q$ is relatively simple, but proving it in $(X,d)$ is daunting. 
For example, consider the system in Figure~\ref{fig:FirstLatent}, which is a latent system of the one in Figure~\ref{fig:IntroVectorSpace}% revealed by the spatial transformation in Figure~\ref{fig:SpatialDeformation}
; perhaps it is easier to prove a property of the system in Figure~\ref{fig:FirstLatent} by showing that it holds in the system in Figure~\ref{fig:IntroVectorSpace} and showing that the spatial transformation in Figure~\ref{fig:SpatialDeformation} preserves it, instead of proving such property directly. 


\section{Automated Repair}
Informally, the system repair problem is the following: given a list of requirements $R$ and a system $(X,c)$, is there a way to make $(X,c)$ satisfy all the requirements in $R$? We can approach a simpler yet related problem with LBA as follows: is there an efficient procedure to determine whether there exists a spatial transformation $m\colon X\rightarrow X$ such that $(X,c\circ m)$ satisfies all the requirements in $R$? If we find such a transformation $m$ and we reveal the latent system $(X,c\circ m)$, we have found a solution for the repair problem. 

Defining the search space for the spatial transformation is not a trivial problem, as we have discussed in Chapters~\ref{ch:Classification} and \ref{ch:CPSRobustness}; moreover, we have not studied important testing or verification considerations if the system $(X,c)$ has computational side-effects (e.g., non-determinism). We believe that this scenario offers yet another practical and interesting use case for LBA, which we would like to study in the future. %to put all these pieces together to obtain a methodology for automatic repair, similar to mutation testing. 

% How can we use transformations ourselves to repurpose a system that is already been defined?
% \todo[inline]{General directions to continue this line of work. There are mainly three directions at the moment}
% \section{Applications to Security Analysis}
% \todo[inline]{A wonderful assertion: no spatial transformation breaks the property behaviour of a system. This implies that an attacker needs to change the program itself, and that model is beyond state integrity.}
% \section{Applications to Program Repair}
% \todo[inline]{We can ourselves morph the state. If we find that some transformations, like the ones we used for program repair, enforce a behavioural property but respect functionality, then we can apply them!}
% \section{Applications to Program Synthesis}
% \todo[inline]{A curious problem: if you have a set of ``gadgets'' defined by an $F$-coalgebra, can you combine them to satisfy a specification?}
% \section{Future work}
% \todo[inline]{This should go in the last chapter!}
% We would like to consider two problems related to latent behaviours: 
% \begin{itemize}
% \item How can we use transformations ourselves to repurpose a system that is already been defined?
% \item How can an attacker use transformations to force a behaviour they want?
% \end{itemize}
% \todo[inline]{Note that, ultimately, both questions need a method to solve an equation for a transformation. That is, given a target behaviour and an a source coalgebra, how do you solve the problem of finding a transformation that helps you display the behaviour you want? Is it even possible?}