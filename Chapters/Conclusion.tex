%!TEX root = ../main.tex
\chapter{Discussion and Conclusion}
Latent behaviour analysis 

We present a small conclusion in each of the chapters of the application module of the thesis, i.e., Chapters~\ref{ch:Classification}, ~\ref{ch:CPSRobustness} and ~\ref{ch:SideChannelRepair}. In this chapter, we discuss and provide a conclusion of LBA as a paradigm for the study of systems, and we discuss possible avenues for future work.

\section{Generality}
it seems like a pretty useful technique in general! 



\section{Predictability} 
By only using spatial transformations $m\colon X\rightarrow X$ and not dynamics transformations $b\colon F(X)\rightarrow F(X)$, we force every latent coalgebra $(X,c\circ m)$ to somehow factor through their original coalgebra $(X,c)$. While these latent coalgebras are clearly and undoubtedly related to their original coalgebra, the relations between the original behaviours and the revealed latent behaviours are, in general, hard to predict from the spatial transformations. We attribute this unpredictability to the lack of restrictions over the choice of spatial transformations. 

In geometry, we can predict the effect of some transformations on objects before we apply them, e.g., symmetries. We believe that there should be a non-trivial family of spatial transformations whose impact on the behaviour of systems is predictable before they are used (the trivial families of spatial transformations are constants and identity transformations). Our intuition points towards spatial transformations that naturally lift to dynamics transformation; more precisely, the transformations where the latent coalgebra $(X, F(m)\circ c)$ and $(X,c\circ m)$ have the same behaviours are predictable. The systems that satisfy this property are known as \emph{bialgebras} \cite{JacobsBook}. We leave formal proof of the predictability of the effects of spatial transformation in these systems as future work.

\section{A Proof Principle}
In this thesis, we studied the effects that a single spatial transformation $m\colon X\rightarrow X$ has on an $F$-coalgebra $(X,c)$; however, since $m$ is an element of the monoid of endofunctions in $X$, it can surely be non-uniquely decomposed into a finite sequence of transformations $m_1, m_2, \ldots m_n$ where $m=m_n\circ\ldots \circ m_2\circ m_1$ each with $m_i\colon X\rightarrow X$, where all $m_i$ preserve a behavioural property $Q$. If that is the case, then $(X,c\circ m)$ should satisfy the property $Q$. This proof principle follows the line of certified compilers (e.g., CompCert~\cite{CompCert}) that can transform one system into another while preserving their behavioural properties.

This proof principle seems particularly useful for a system $(X,d)$ that can be described as a latent coalgebra of a system $(X,c)$ and a spatial transformation $m$ (i.e., $d=c\circ m$), where $(X,c)$ is a system where proving the property $Q$ is relatively simple, but proving it in $(X,d)$ is daunting. 
For example, consider the system in Figure~\ref{fig:FirstLatent}, which is a latent system of the one in Figure~\ref{fig:IntroVectorSpace}% revealed by the spatial transformation in Figure~\ref{fig:SpatialDeformation}
; perhaps it is easier to prove a property of the system in Figure~\ref{fig:FirstLatent} by showing that it holds in the system in Figure~\ref{fig:IntroVectorSpace} and showing that the spatial transformation in Figure~\ref{fig:SpatialDeformation} preserves it, instead of proving such property directly. 


\section{System Repurposing}
How can we use transformations ourselves to repurpose a system that is already been defined?
% \todo[inline]{General directions to continue this line of work. There are mainly three directions at the moment}
% \section{Applications to Security Analysis}
% \todo[inline]{A wonderful assertion: no spatial transformation breaks the property behaviour of a system. This implies that an attacker needs to change the program itself, and that model is beyond state integrity.}
% \section{Applications to Program Repair}
% \todo[inline]{We can ourselves morph the state. If we find that some transformations, like the ones we used for program repair, enforce a behavioural property but respect functionality, then we can apply them!}
% \section{Applications to Program Synthesis}
% \todo[inline]{A curious problem: if you have a set of ``gadgets'' defined by an $F$-coalgebra, can you combine them to satisfy a specification?}
\section{Future work}
\todo[inline]{This should go in the last chapter!}
We would like to consider two problems related to latent behaviours: 
\begin{itemize}
\item How can we use transformations ourselves to repurpose a system that is already been defined?
\item How can an attacker use transformations to force a behaviour they want?
\end{itemize}
\todo[inline]{Note that, ultimately, both questions need a method to solve an equation for a transformation. That is, given a target behaviour and an a source coalgebra, how do you solve the problem of finding a transformation that helps you display the behaviour you want? Is it even possible?}